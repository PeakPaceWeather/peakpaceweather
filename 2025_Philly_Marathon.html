<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Peak Pace Weather — AACR Philadelphia Marathon -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
  <title id="pageTitle">AACR Philadelphia Marathon | Peak Pace</title>

  <!-- Fonts & Libraries -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
/* ===== Base + Responsive (pinch-zoom enabled) ===== */
html, body { overflow-x: hidden; touch-action: pan-x pan-y; zoom: 1; }
body { margin: 0; padding: 0; font-family: "Source Sans Pro", Arial, sans-serif; color: #111; background: #fff; line-height: 1.5; }
:root { --ink:#111; --muted:#555; --line:#ddd; --pp-dark:#003546; --blaze:#37BC7D; --highlight:#FF6700; --hoverRow:#fff3e6; }

/* ===== Layout + Header ===== */
.page-wrapper { width: 1000px; margin: 0 auto; padding: 0; box-sizing: border-box; }
.main-header { text-align: center; font-family: "Montserrat", sans-serif; font-weight: 800; font-size: clamp(36px, 6vw, 52px); letter-spacing: .05em; text-transform: uppercase; color: #000; margin: 28px 0 18px; line-height: 1; }
header { text-align:center; margin:8px auto 14px; }
header h2 { margin:0; font-size:32px; font-weight:700; }
#countdown { font-size:20px; font-weight:600; margin-top:6px; color:#333; }

/* ===== Uniform panel widths ===== */
section, #elevSection, #map, #paceBox { width: 960px; max-width: 960px; margin: 18px auto 0; box-sizing: border-box; }
section, #elevSection { border:1px solid #ccc; border-radius:8px; background:#fff; padding:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
section:last-of-type { margin-bottom:24px; }
section h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }

/* Map */
#map { height: 600px; margin-top:10px; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }

/* Elevation */
#elevSection { width: 960px; max-width: 960px; margin: 18px auto; border: 1px solid #ccc; border-radius: 8px; background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.08); padding: 16px; box-sizing: border-box; }
#elevWrap { position:relative; width:100%; height:225px; margin:0 auto; padding:0; box-sizing:border-box; }
#elevationChart { position:absolute; inset:0; width:100% !important; height:100% !important; display:block; box-sizing:border-box; cursor:pointer; }

/* ===== Pace & Wave Control Bar ===== */
#paceBox { text-align:center; padding:20px 24px; margin:18px auto; background:#fff; border:1px solid #ccc; border-radius:10px; box-shadow:0 2px 4px rgba(0,0,0,0.08); }
#paceBox.loading { opacity: 0.6; pointer-events: none; }

.control-row { display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:16px; padding-bottom:16px; border-bottom:1px solid #eee; }
.control-row:last-of-type { margin-bottom:0; padding-bottom:0; border-bottom:none; }
.control-row label { font-weight:700; color:#000; font-size:15px; }
.control-row select, .control-row input { font-size:14px; border:1px solid #ccc; border-radius:6px; background:#fff; color:#111; padding:8px 12px; cursor:pointer; height:38px; }
#stationSelect { min-width: 380px; }
#waveSelect { min-width: 380px; }
#customTimeInput { display:none; min-width: 150px; }
#paceMin, #paceSec { min-width:65px; width:65px; }

.pace-input-group { display:flex; align-items:center; gap:6px; white-space:nowrap; }
.pace-input-group span { color:#666; font-size:16px; font-weight:700; }

#paceGo { font-size:14px; font-weight:600; border:1px solid #003546; border-radius:6px; color:#fff; background:#003546; cursor:pointer; padding:9px 20px; height:38px; transition:background 0.2s ease; margin-left:4px; }
#paceGo:hover { background:#FF6700; }
#paceGo:disabled { background:#ccc; cursor:not-allowed; border-color:#ccc; }

#paceConfirm { font-size:14px; color:#888; margin-left:12px; font-style:italic; }
#paceConfirm.success { color:#37BC7D; font-style:normal; font-weight:500; }

/* Tables */
table { width:100%; border-collapse:collapse; }
th, td { border:1px solid #ccc; padding:8px; text-align:center; font-size:14px; }
th { background:#f0f0f0; font-weight:700; }
#climoAvgRow { font-weight:700; background:#f5f5f5; }

/* Hover (desktop) */
#forecastBody tr:hover, .climoBody tr:hover { background: var(--hoverRow); }

/* Tap highlight (mobile & desktop) */
#forecastBody tr, .climoBody tr { cursor: pointer; -webkit-tap-highlight-color: transparent; }
.highlight-row { background: var(--hoverRow) !important; box-shadow: inset 0 0 0 2px var(--highlight); transition: background .2s ease, box-shadow .2s ease; }

.note { font-size:12px; text-align:center; margin-top:8px; color:var(--muted); }

/* Leaflet styles & tooltips */
.leaflet-marker-icon { cursor:pointer; transition: transform 150ms ease; }
.leaflet-marker-icon:hover { transform: scale(1.2); }
.leaflet-tooltip, .pp-tooltip { background:#fff; border:2px solid var(--highlight); border-radius:8px; color:var(--ink); font-size:13px; font-weight:500; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:6px 10px; }
.leaflet-control a { background-color:var(--pp-dark) !important; color:#fff !important; border:1px solid var(--pp-dark) !important; width:30px !important; height:30px !important; line-height:30px !important; text-align:center; font-size:16px; }
.leaflet-control a:hover { background-color: var(--blaze) !important; border-color: var(--blaze) !important; }

/* Blaze markers */
.blaze-dot { width:20px; height:20px; background:var(--blaze); border:2px solid #222; border-radius:50%; transition:transform .2s ease; transform-origin:center; }
.blaze-dot:hover { transform: scale(1.4); cursor:pointer; }
.blaze-dot.highlighted { transform: scale(1.6); background: var(--highlight); }

/* Climo tabs */
#climoTabs { display:flex; justify-content:center; margin-bottom:12px; gap:8px; }
.climoTab { padding:6px 14px; border:1px solid var(--pp-dark); border-radius:6px 6px 0 0; background:#f9f9f9; color:var(--pp-dark); font-size:14px; font-weight:600; cursor:pointer; transition: background .2s ease, color .2s ease; }
.climoTab:hover { background: var(--hoverRow); }
.climoTab.active { background: var(--pp-dark); color:#fff; }
.climoPanel { display:none; }
.climoPanel.active { display:block; }

/* Prevent focus-snap on Leaflet */
.leaflet-container { scroll-margin-top:0; scroll-behavior:auto; }
.leaflet-container:focus { outline:none; scroll-margin-top:0; }

/* Loading spinner */
.spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid var(--pp-dark); border-radius: 50%; animation: spin 1s linear infinite; margin-left: 8px; vertical-align: middle; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

</style>
</head>

<body>
  <div class="page-wrapper">
    <div class="main-header">PEAK PACE WEATHER</div>

    <header>
      <h2 id="raceName">AACR Philadelphia Marathon</h2>
      <div id="countdown">Loading countdown…</div>
    </header>

    <!-- ============ Climatology (date-driven) ============ -->
    <section id="climatology">
      <h3 id="climoTitle">Climatology</h3>
      <div id="climoTabs"></div>
      <div id="climoPanels"></div>
    </section>

    <!-- Pace Controls -->
    <div id="paceBox">
      <div class="control-row">
        <label for="stationSelect">Step 1 - Station Option:</label>
        <select id="stationSelect">
          <option value="">Select forecast locations...</option>
          <option value="option1">Every Mile Marker (0-26)</option>
          <option value="option2">Every 5K Split (8 locations)</option>
          <option value="option3">Aid Stations (16 locations)</option>
        </select>
      </div>
      
      <div class="control-row">
        <label for="waveSelect">Step 2 - Corral Start Time:</label>
        <select id="waveSelect" disabled>
          <option value="">Complete Step 1 first</option>
        </select>
        <input type="time" id="customTimeInput" />
      </div>
      
      <div class="control-row">
        <label for="paceMin">Step 3 - Target Pace (min/mi):</label>
        <div class="pace-input-group">
          <select id="paceMin" disabled><option>--</option></select>
          <span>:</span>
          <select id="paceSec" disabled><option>--</option></select>
        </div>
      </div>
      
      <div class="control-row">
        <button id="paceGo" disabled>Step 4 - Generate Peak Pace Forecast</button>
        <span id="paceConfirm">Complete steps 1-3 above</span>
      </div>
    </div>

    <!-- Map -->
    <div id="map"></div>

    <!-- Elevation -->
    <section id="elevSection">
      <h3>Elevation Profile</h3>
      <div id="elevWrap"><canvas id="elevationChart"></canvas></div>
    </section>

    <!-- Forecast Summary -->
    <section id="summary">
      <h3 id="tableHeader" style="margin-bottom:14px;">Peak Pace Forecast</h3>
      <table>
        <thead>
          <tr><th>Station</th><th>Distance (mi)</th><th>Elapsed</th><th>ETA</th><th>Temp (°F)</th><th>Wind</th><th>Conditions</th></tr>
        </thead>
        <tbody id="forecastBody">
          <tr id="forecastPlaceholder">
            <td colspan="7" style="text-align:center; padding:40px 20px; color:#888; font-style:italic;">
              Complete steps 1-4 above to generate your Peak Pace Forecast
            </td>
          </tr>
        </tbody>
      </table>
      <div style="text-align:center; font-size:12px; color:#555; margin-top:12px;">
        <span id="forecastValidLabel"></span>
        <br>
        <span id="sourceLabel" style="color:#777;"></span>
      </div>
    </section>

    <!-- Sources -->
    <section id="sources">
      <h3>Data Sources</h3>
      <ul style="font-size:13px; color:#555; line-height:1.5;">
        <li>Climatology: Iowa State University <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">IEM ASOS Archive</a></li>
        <li>Elevation: Mapbox Terrain-RGB</li>
        <li>Weather Forecasts: NOAA/NWS API (near-term) and Open-Meteo (extended range)</li>
      </ul>
    </section>
  </div>
</body>

<!-- ============ CONFIG ============ -->
<script>
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGlsbG9uZHVyaW5pY2siLCJhIjoiY21memtlbm83MDNycTJtb3JtdGxucWpkMiJ9.W7Ge6XYCd0Gfl9f7YQ2dNw";

const raceConfig = {
  name: "AACR Philadelphia Marathon",
  date: new Date("2025-11-23T07:00:00-05:00"),
  city: "Philadelphia, PA",
  climoStationId: "KPHL",
  climoStationName: "Philadelphia International Airport",
  climoBaseUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/",
  routeUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_Philly_Route.json",
  stationUrls: {
    option1: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_Philly_Stations_Option1.json",
    option2: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_Philly_Stations_Option2.json",
    option3: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_Philly_Stations_Option3.json"
  },
  multiDaySpan: 1,
  elevationZoom: 13,
  route: null,
  stations: null
};
</script>

<!-- ============ COUNTDOWN ============ -->
<script>
function updateCountdown() {
  const diff = raceConfig.date - new Date();
  const el = document.getElementById("countdown");
  const raceDateStr = raceConfig.date.toLocaleString([], { month:"long", day:"numeric", year:"numeric" });
  if (diff <= 0) { el.textContent = `${raceDateStr} (Today)`; return; }
  
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  
  let countdownText = "";
  if (days > 0) {
    countdownText = `${days} ${days === 1 ? 'Day' : 'Days'}`;
  }
  if (hours > 0 || days > 0) {
    if (days > 0) countdownText += " and ";
    countdownText += `${hours} ${hours === 1 ? 'Hour' : 'Hours'}`;
  }
  countdownText += " Until Race Day";
  
  el.textContent = `${raceDateStr} (${countdownText})`;
}
setInterval(updateCountdown, 60000);
updateCountdown();
</script>

<!-- ============ PACE & UI CONTROLS ============ -->
<script>
function paceMinPerMiFromUI(){
  const m = Number(document.getElementById('paceMin').value) || 0;
  const s = Number(document.getElementById('paceSec').value) || 0;
  return m + s/60;
}
function formatElapsedFromMinutes(mins){
  const totalSeconds = Math.round(mins * 60);
  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// Initialize pace dropdowns
(function initPace(){
  const mins=document.getElementById('paceMin'), secs=document.getElementById('paceSec');
  for(let m=4;m<=30;m++){ let o=document.createElement('option'); o.value=m; o.textContent=m; mins.appendChild(o); }
  for(let s=0;s<60;s++){ let o=document.createElement('option'); o.value=s; o.textContent=String(s).padStart(2,'0'); secs.appendChild(o); }
  mins.value=9; secs.value=0;
})();

// Step 1: Station selection
document.getElementById('stationSelect').addEventListener('change', async function() {
  const option = this.value;
  if (!option) return;
  
  // Enable Step 2
  const waveSelect = document.getElementById('waveSelect');
  waveSelect.disabled = false;
  waveSelect.innerHTML = `
    <option value="06:55">6:55 AM - Push Rim Wheelchair Athletes</option>
    <option value="07:00" selected>7:00 AM - Corrals A & B</option>
    <option value="07:10">7:10 AM - Corrals C & D</option>
    <option value="07:20">7:20 AM - Corrals E & F</option>
    <option value="07:30">7:30 AM - Corrals G & H</option>
    <option value="custom">Custom Start Time</option>
  `;
  
  // Load station data
  try {
    const res = await fetch(raceConfig.stationUrls[option]);
    raceConfig.stations = await res.json();
    console.log(`Loaded ${raceConfig.stations.length} stations for ${option}`);
    
    // Redraw markers if map is ready
    if (window.mapReady) {
      redrawMarkers();
    }
  } catch(e) {
    console.error('Failed to load stations:', e);
  }
  
  checkAllStepsComplete();
});

// Step 2: Wave/Corral selection
document.getElementById('waveSelect').addEventListener('change', function() {
  const customInput = document.getElementById('customTimeInput');
  if (this.value === 'custom') {
    customInput.style.display = 'inline-block';
    customInput.value = '07:00';
  } else {
    customInput.style.display = 'none';
    const [hh, mm] = this.value.split(':').map(Number);
    const base = new Date(raceConfig.date);
    base.setHours(hh, mm, 0, 0);
    raceConfig.date = base;
  }
  
  // Enable Step 3
  document.getElementById('paceMin').disabled = false;
  document.getElementById('paceSec').disabled = false;
  
  checkAllStepsComplete();
});

document.getElementById('customTimeInput').addEventListener('change', function() {
  const [hh, mm] = this.value.split(':').map(Number);
  const base = new Date("2025-11-23T00:00:00-05:00");
  base.setHours(hh, mm, 0, 0);
  raceConfig.date = base;
  checkAllStepsComplete();
});

// Step 3: Pace selection
document.getElementById('paceMin').addEventListener('change', checkAllStepsComplete);
document.getElementById('paceSec').addEventListener('change', checkAllStepsComplete);

function checkAllStepsComplete() {
  const step1 = document.getElementById('stationSelect').value !== '';
  const step2 = document.getElementById('waveSelect').value !== '';
  const step3 = document.getElementById('paceMin').value !== '--';
  
  const goBtn = document.getElementById('paceGo');
  const confirmEl = document.getElementById('paceConfirm');
  
  if (step1 && step2 && step3) {
    goBtn.disabled = false;
    confirmEl.textContent = 'Ready to generate forecast!';
    confirmEl.classList.remove('success');
  } else {
    goBtn.disabled = true;
    let msg = 'Complete ';
    const missing = [];
    if (!step1) missing.push('step 1');
    if (!step2) missing.push('step 2');
    if (!step3) missing.push('step 3');
    msg += missing.join(', ');
    confirmEl.textContent = msg;
    confirmEl.classList.remove('success');
  }
}

// Step 4: Generate forecast
document.getElementById('paceGo').addEventListener('click', async function() {
  const paceBox = document.getElementById('paceBox');
  const goBtn = this;
  const confirmEl = document.getElementById('paceConfirm');
  
  // Disable all controls
  paceBox.classList.add('loading');
  goBtn.disabled = true;
  
  // Show loading state
  const originalText = goBtn.textContent;
  goBtn.innerHTML = 'Generating Forecast<span class="spinner"></span>';
  
  try {
    await updateForecasts();
    
    // Success message
    const paceM = String(document.getElementById('paceMin').value).padStart(2,"0");
    const paceS = String(document.getElementById('paceSec').value).padStart(2,"0");
    const startTimeStr = raceConfig.date.toLocaleTimeString([], { hour:"numeric", minute:"2-digit" }).toLowerCase();
    
    confirmEl.textContent = `Forecast generated! Start: ${startTimeStr} | Pace: ${paceM}:${paceS} min/mi`;
    confirmEl.classList.add('success');
  } catch(e) {
    confirmEl.textContent = 'Error generating forecast. Please try again.';
    confirmEl.style.color = '#d00';
  } finally {
    // Re-enable controls
    goBtn.innerHTML = originalText;
    goBtn.disabled = false;
    paceBox.classList.remove('loading');
  }
});
</script>

<!-- ============ CLIMATOLOGY (date-driven) ============ -->
<script>
function monthName(d){ return d.toLocaleString('en-US', { month:'long' }); }
function climoFilenameFor(dateObj){ const mn = monthName(dateObj); const day = dateObj.getDate(); return `${mn}_${day}_Climate.json`; }
function shortMonthDay(d){ return d.toLocaleString('en-US', { month:'short', day:'numeric' }); }

function populateClimoTable(data, bodyEl, avgRowEl){
  bodyEl.innerHTML = "";
  let sumMax=0, sumMin=0, sumP=0, n=0;
  data.forEach(row => {
    const max = Number(row.max), min = Number(row.min);
    let precipDisplay, precipValue;
    if (row.precip === "T" || row.precip === "t") {
      precipDisplay = "T";
      precipValue = 0;
    } else {
      precipValue = Number(row.precip);
      precipDisplay = isNaN(precipValue) ? "—" : precipValue.toFixed(2);
    }
    
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.year}</td>
      <td>${isNaN(max) ? "—" : max.toFixed(1)}</td>
      <td>${isNaN(min) ? "—" : min.toFixed(1)}</td>
      <td>${precipDisplay}</td>
      <td>${row.conditions || "—"}</td>`;
    bodyEl.appendChild(tr);
    if(!isNaN(max)) sumMax+=max;
    if(!isNaN(min)) sumMin+=min;
    if(!isNaN(precipValue)) sumP+=precipValue;
    n++;
  });
  if(n>0){
    avgRowEl.innerHTML = `<td>Averages</td>
      <td>${(sumMax/n).toFixed(1)}</td>
      <td>${(sumMin/n).toFixed(1)}</td>
      <td>${(sumP/n).toFixed(2)}</td>
      <td>—</td>`;
  }
}

function buildClimoPanel(panelId){
  const panel = document.createElement('div');
  panel.className = 'climoPanel';
  panel.id = panelId;
  panel.innerHTML = `
    <table>
      <thead><tr>
        <th>Year</th><th>Max Temp (°F)</th><th>Min Temp (°F)</th>
        <th>Precipitation (")</th><th>Conditions</th>
      </tr></thead>
      <tbody class="climoBody"></tbody>
      <tfoot><tr id="climoAvgRow"><td>Averages</td><td>—</td><td>—</td><td>—</td><td>—</td></tr></tfoot>
    </table>
    <div class="note climoNote"></div>`;
  return panel;
}

async function loadClimatology() {
  const start = new Date(raceConfig.date);
  const span = Math.max(1, Number(raceConfig.multiDaySpan) || 1);

  const climoTitle = document.getElementById('climoTitle');
  const raceDateStr = start.toLocaleDateString([], { month:"long", day:"numeric" });
  climoTitle.textContent = `Climatology – ${raceDateStr} – ${raceConfig.city}`;

  const tabs = document.getElementById('climoTabs');
  const panels = document.getElementById('climoPanels');
  tabs.innerHTML = ""; panels.innerHTML = "";

  const tabButtons = [];
  for (let i = 0; i < span; i++) {
    const d = new Date(start.getTime() + i*24*60*60*1000);
    const tab = document.createElement('button');
    tab.className = 'climoTab';
    tab.dataset.dayIndex = String(i);
    tab.textContent = shortMonthDay(d);
    tabButtons.push(tab);
    tabs.appendChild(tab);

    const panel = buildClimoPanel(`climoPanel_${i}`);
    panels.appendChild(panel);
  }

  if (span === 1) { tabs.style.display = 'none'; }

  function activate(idx){
    panels.querySelectorAll('.climoPanel').forEach(p => p.classList.remove('active'));
    tabButtons.forEach(b => b.classList.remove('active'));
    const p = document.getElementById(`climoPanel_${idx}`);
    if (p) p.classList.add('active');
    if (span>1 && tabButtons[idx]) tabButtons[idx].classList.add('active');
  }
  if (span>1) tabButtons.forEach((btn,i)=>btn.addEventListener('click',()=>activate(i)));
  activate(0);

  for (let i=0; i<span; i++){
    const d = new Date(start.getTime() + i*24*60*60*1000);
    const file = climoFilenameFor(d);
    const url = raceConfig.climoBaseUrl + file;

    const panel = document.getElementById(`climoPanel_${i}`);
    const bodyEl = panel.querySelector('.climoBody');
    const avgRowEl = panel.querySelector('#climoAvgRow');
    const noteEl = panel.querySelector('.climoNote');

    noteEl.textContent = `10-year climatology (2015-2024) from KPHL (Philadelphia International Airport). The airport is 7 miles southwest of the Art Museum start. Weather conditions can vary across the course and from year to year.`;

    try{
      const res = await fetch(url);
      if(!res.ok) throw new Error("bad climo response");
      const data = await res.json();
      populateClimoTable(data, bodyEl, avgRowEl);
    }catch(err){
      console.error('Climo load failed:', file, err);
      bodyEl.innerHTML = `<tr><td colspan="5">Climatology data unavailable for ${shortMonthDay(d)}</td></tr>`;
    }
  }
}
document.addEventListener('DOMContentLoaded', loadClimatology);
</script>

<!-- ============ TERRAIN + ELEVATION ============ -->
<script>
function latLonToTileXY(lat, lon, z){
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const y = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
  return {x,y};
}
function latLonToPixelXYInTile(lat, lon, z, tileSize=256){
  const n = Math.pow(2, z);
  const xtile = (lon + 180) / 360 * n;
  const latRad = lat * Math.PI/180;
  const ytile = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n;
  const px = Math.floor((xtile - Math.floor(xtile)) * tileSize);
  const py = Math.floor((ytile - Math.floor(ytile)) * tileSize);
  return {px, py};
}
function decodeTerrainRGB(r,g,b){ return -10000 + (r*256*256 + g*256 + b) * 0.1; }

const tileCache = new Map();
async function getTileImageData(z,x,y){
  const key = `${z}/${x}/${y}`;
  if (tileCache.has(key)) return tileCache.get(key);
  const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${MAPBOX_TOKEN}`;
  const img = new Image(); img.crossOrigin = 'anonymous';
  const loaded = new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=(e)=>rej(e); });
  img.src = url; await loaded;
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
  const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
  const imageData = ctx.getImageData(0,0,256,256);
  const record = { imageData }; tileCache.set(key, record); return record;
}
async function getElevationMetersAt(lat, lon, z){
  const {x,y} = latLonToTileXY(lat, lon, z);
  const {px,py} = latLonToPixelXYInTile(lat, lon, z, 256);
  try{
    const { imageData } = await getTileImageData(z,x,y);
    const idx = (py*256 + px) * 4;
    const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
    return decodeTerrainRGB(r,g,b);
  }catch(e){ return null; }
}
function haversineMi(a,b){
  const R=3958.7613; const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLon=toRad(b[1]-a[1]); const la1=toRad(a[0]);
  const h=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

let elevChart = null, profileDistances = [], profileElevations = [], currentHighlightIndices = new Set();
function elevationAtMile(mile) {
  if (!profileDistances.length) return null;
  for (let i=1;i<profileDistances.length;i++) {
    if (profileDistances[i] >= mile) {
      const d0 = profileDistances[i-1], d1 = profileDistances[i];
      const e0 = profileElevations[i-1], e1 = profileElevations[i-1] == null ? null : profileElevations[i];
      if (e0==null || e1==null) return null;
      const t = (mile-d0)/(d1-d0);
      return e0 + t*(e1-e0);
    }
  }
  return profileElevations[profileElevations.length-1];
}
async function buildElevationProfile(routeCoords, z){
  const fullDistances = [0];
  for(let i=1;i<routeCoords.length;i++) fullDistances[i] = fullDistances[i-1] + haversineMi(routeCoords[i-1], routeCoords[i]);
  const sampled = [], sampledDistances = [];
  for (let i=0;i<routeCoords.length;i+=10){ sampled.push(routeCoords[i]); sampledDistances.push(fullDistances[i]); }
  if (sampled[sampled.length-1] !== routeCoords[routeCoords.length-1]) {
    sampled.push(routeCoords[routeCoords.length-1]);
    sampledDistances.push(fullDistances[fullDistances.length-1]);
  }
  const meters=[];
  for (const [lat,lon] of sampled){ meters.push(await getElevationMetersAt(lat,lon,z)); }
  const feet = meters.map(m => (m!=null ? m*3.28084 : null));
  return { distances: sampledDistances, elevations: feet, sampled };
}
function buildElevationChart(distances, elevations, stations){
  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevChart) elevChart.destroy();
  profileDistances = distances; profileElevations = elevations;
  const stationPoints = stations.map(s => ({ x: s.miles, y: elevationAtMile(s.miles) }));
  elevChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label:'Elevation', data: profileDistances.map((d,i)=>({x:d,y:elevations[i]})), parsing:false, borderColor:'#000', pointRadius:0, borderWidth:1.5, fill:false, tension:0.1 },
        {
          label:'Stations', type:'scatter', data: stationPoints, parsing:false, pointRadius:6, hoverRadius:10, hitRadius:12,
          pointBackgroundColor: (c) => {
            const idx = c.dataIndex;
            return (elevChart && currentHighlightIndices.has(idx))
              ? getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700'
              : getComputedStyle(document.documentElement).getPropertyValue('--blaze').trim() || '#37BC7D';
          },
          pointBorderColor:'#222', pointBorderWidth:1
        }
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } },
      plugins: {
        legend: { display:false },
        tooltip: {
          enabled:true, filter: ctx => ctx.datasetIndex === 1,
          callbacks: {
            title: (ctx) => {
              const station = stations[ctx[0].dataIndex];
              return `${station.name} – Mile ${station.miles.toFixed(1)}`;
            },
            label: (ctx) => {
              const station = stations[ctx.dataIndex];
              const pace = paceMinPerMiFromUI();
              const elapsed = formatElapsedFromMinutes(station.miles * pace);
              if (station.forecasts && station.forecasts.length) {
                return station.forecasts.map(f => [
                  `Elapsed: ${elapsed}`,
                  `ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}`,
                  `Temp: ${f.temp}`, `Wind: ${f.wind}`, `Conditions: ${f.cond}`
                ]).flat();
              }
              return [`Elapsed: ${elapsed}`, "Forecast: —"];
            }
          },
          backgroundColor:'#fff',
          borderColor: getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700',
          borderWidth:2, titleColor:'#111', bodyColor:'#111', padding:8, displayColors:false
        }
      },
      interaction: { mode:'point', intersect:true },
      onHover: (event, elements) => {
        const canvas = event.chart.canvas;
        if (elements.length > 0 && elements[0].datasetIndex === 1) {
          canvas.style.cursor = 'pointer';
          const idx = elements[0].index;
          highlightByStationIndex(idx);
        } else {
          canvas.style.cursor = 'default';
          clearHighlights();
          event.chart.tooltip.setActiveElements([], {x:0,y:0});
          event.chart.update();
        }
      },
      scales: {
        x: { type:'linear', title:{ display:true, text:'Distance (mi)' }, min:0, max:26.2 },
        y: { title:{ display:true, text:'Elevation (ft)' }, ticks:{ autoSkip:true, maxTicksLimit:6 } }
      }
    }
  });
  ctx.canvas.addEventListener("mouseleave", () => {
    if (elevChart) {
      elevChart.tooltip.setActiveElements([], {x:0,y:0});
      elevChart.update();
      clearHighlights();
    }
  });
}
</script>

<!-- ============ MAP + MARKERS + FORECASTS ============ -->
<script>
async function getNOAAForecast(lat, lon, targetDate) {
  try {
    const pointRes = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    const pointData = await pointRes.json();
    const fRes = await fetch(pointData.properties.forecastHourly);
    const fData = await fRes.json();
    const periods=fData?.properties?.periods||[];
    if (!periods.length) return null;
    return periods.reduce((p,c)=>
      Math.abs(new Date(c.startTime)-targetDate) < Math.abs(new Date(p.startTime)-targetDate) ? c : p
    );
  } catch { return null; }
}

async function getOpenMeteoForecast(lat, lon, targetDate) {
  try {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,wind_speed_10m,wind_direction_10m,weather_code&temperature_unit=fahrenheit&wind_speed_unit=mph&timezone=auto`;
    const res = await fetch(url);
    const data = await res.json();
    
    if (!data.hourly || !data.hourly.time) return null;
    
    const times = data.hourly.time.map(t => new Date(t));
    let closestIdx = 0;
    let minDiff = Math.abs(times[0] - targetDate);
    
    for (let i = 1; i < times.length; i++) {
      const diff = Math.abs(times[i] - targetDate);
      if (diff < minDiff) {
        minDiff = diff;
        closestIdx = i;
      }
    }
    
    const weatherCode = data.hourly.weather_code[closestIdx];
    const weatherDescriptions = {
      0: "Clear", 1: "Mainly Clear", 2: "Partly Cloudy", 3: "Overcast",
      45: "Foggy", 48: "Depositing Rime Fog",
      51: "Light Drizzle", 53: "Moderate Drizzle", 55: "Dense Drizzle",
      56: "Light Freezing Drizzle", 57: "Dense Freezing Drizzle",
      61: "Slight Rain", 63: "Moderate Rain", 65: "Heavy Rain",
      66: "Light Freezing Rain", 67: "Heavy Freezing Rain",
      71: "Slight Snow", 73: "Moderate Snow", 75: "Heavy Snow",
      77: "Snow Grains",
      80: "Slight Rain Showers", 81: "Moderate Rain Showers", 82: "Violent Rain Showers",
      85: "Slight Snow Showers", 86: "Heavy Snow Showers",
      95: "Thunderstorm", 96: "Thunderstorm with Slight Hail", 99: "Thunderstorm with Heavy Hail"
    };
    
    const temp = data.hourly.temperature_2m[closestIdx];
    const windSpeed = data.hourly.wind_speed_10m[closestIdx];
    const windDir = data.hourly.wind_direction_10m[closestIdx];
    const windDirCardinal = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(windDir / 22.5) % 16];
    
    return {
      temperature: Math.round(temp),
      windSpeed: `${Math.round(windSpeed)} mph`,
      windDirection: windDirCardinal,
      shortForecast: weatherDescriptions[weatherCode] || "Unknown"
    };
  } catch (err) {
    console.error('OpenMeteo error:', err);
    return null;
  }
}

function bindMarkerTooltip(marker) {
  marker.bindTooltip("", { direction: "auto", offset: [0, -10], opacity: 0.95, className: "pp-tooltip", sticky: false, autoPan: true });
}

const map = L.map('map', {
  keyboard: false,
  scrollWheelZoom: false,
  touchZoom: 'center',
  zoomControl: true,
  dragging: true
}).setView([39.9652, -75.1800], 12);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

let markers = [];
let groupList = [];
let stationIndexToGroup = [];
window.mapReady = false;

function applyMarkerHighlights(activeGroupIdx){
  markers.forEach((m,i)=>{ const dot = m.getElement()?.querySelector('.blaze-dot'); if (dot) dot.classList.toggle("highlighted", i === activeGroupIdx); });
}
function applyChartHighlights(indices){
  currentHighlightIndices = new Set(indices);
  if (elevChart){ elevChart.setActiveElements(indices.map(i=>({datasetIndex:1,index:i}))); elevChart.update(); }
}
function highlightByStationIndex(stationIdx){
  const gIdx = stationIndexToGroup[stationIdx];
  applyMarkerHighlights(gIdx);
  applyChartHighlights([stationIdx]);
}
function highlightByGroupIndex(groupIdx){
  const indices = groupList[groupIdx].indices;
  applyMarkerHighlights(groupIdx);
  applyChartHighlights(indices);
}
function clearHighlights(){
  currentHighlightIndices.clear();
  markers.forEach(m=>m.getElement()?.querySelector('.blaze-dot')?.classList.remove("highlighted"));
  if(elevChart){ elevChart.setActiveElements([]); elevChart.update(); }
}
const blazeIcon = L.divIcon({ className:"", html:'<div class="blaze-dot"></div>', iconSize:[20,20], iconAnchor:[10,10] });

function tooltipLinesMapGroup(g, stations) {
  let html = "";
  g.indices.forEach((i, idx) => {
    const s = stations[i];
    if (idx > 0) html += `<hr style="margin:6px 0;">`
    const pace = paceMinPerMiFromUI();
    const elapsed = formatElapsedFromMinutes(s.miles * pace);
    html += `<div style="margin-bottom:6px;">
      <strong>${s.name} – Mile ${s.miles.toFixed(1)}</strong><br>`;
    if (s.forecasts && s.forecasts.length) {
      s.forecasts.forEach(f => {
        html += `Elapsed: ${elapsed}<br>
                 ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}<br>
                 Temp: ${f.temp}<br>
                 Wind: ${f.wind}<br>
                 Conditions: ${f.cond}<br>`;
      });
    } else {
      html += `Elapsed: ${elapsed}<br>Forecast: —<br>`;
    }
    html += `</div>`;
  });
  return html;
}

function redrawMarkers() {
  // Clear existing markers
  markers.forEach(m => m.remove());
  markers = [];
  groupList = [];
  stationIndexToGroup = [];
  
  if (!raceConfig.stations) return;
  
  // Group stations by lat/lon
  const groupsByKey = {};
  raceConfig.stations.forEach((s, idx) => {
    const key = `${s.lat},${s.lon}`;
    if (!groupsByKey[key]) groupsByKey[key] = { lat:s.lat, lon:s.lon, indices:[] };
    groupsByKey[key].indices.push(idx);
  });
  groupList = Object.values(groupsByKey);
  
  // Place markers
  groupList.forEach((g, gIdx) => {
    g.indices.forEach(stIdx => { stationIndexToGroup[stIdx] = gIdx; });
    const marker = L.marker([g.lat, g.lon], { icon: blazeIcon }).addTo(map);
    g.marker = marker;
    markers.push(marker);
    bindMarkerTooltip(marker);
    marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations));
    marker.on("mouseover", () => highlightByGroupIndex(gIdx));
    marker.on("mouseout", clearHighlights);
  });
  
  // Rebuild elevation chart with new stations
  if (raceConfig.route && profileDistances.length) {
    buildElevationChart(profileDistances, profileElevations, raceConfig.stations);
  }
}

// Load route and initial setup
fetch(raceConfig.routeUrl).then(r=>r.json()).then(async(route)=>{
  raceConfig.route = route;
  
  const line = L.polyline(route, {color:"#000", weight:3}).addTo(map);
  map.fitBounds(line.getBounds());
  
  // Build elevation
  try {
    const {distances, elevations} = await buildElevationProfile(route, raceConfig.elevationZoom);
    profileDistances = distances;
    profileElevations = elevations;
  } catch(e) {
    console.error('Elevation error', e);
    const distances = [0];
    for(let i=1; i<route.length; i++) distances[i] = distances[i-1] + haversineMi(route[i-1], route[i]);
    profileDistances = distances;
    profileElevations = distances.map(() => 100);
  }
  
  window.mapReady = true;
});

async function updateForecasts(){
  const tbody = document.getElementById("forecastBody");
  const validLabel = document.getElementById("forecastValidLabel");
  const sourceLabel = document.getElementById("sourceLabel");
  tbody.innerHTML = "";

  const pace = paceMinPerMiFromUI();
  const now = new Date();
  const noaaHorizonHours = 6.5 * 24;
  const openMeteoHorizonHours = 16 * 24;

  let minHrs = Infinity;
  for (const s of (raceConfig.stations || [])){
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const hrs = (eta - now) / 3_600_000;
    if (hrs < minHrs) minHrs = hrs;
  }

  if (minHrs <= noaaHorizonHours) {
    validLabel.textContent = `Forecast valid as of ${new Date().toLocaleString()}`;
    sourceLabel.textContent = `Source: NOAA forecastHourly`;
  } else if (minHrs <= openMeteoHorizonHours) {
    validLabel.textContent = `Forecast valid as of ${new Date().toLocaleString()}`;
    sourceLabel.textContent = `Source: Open-Meteo`;
  } else {
    validLabel.textContent = ``;
    sourceLabel.textContent = ``;
  }

  for (const s of (raceConfig.stations || [])){
    const elapsedStr = formatElapsedFromMinutes(s.miles * pace);
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const timeStr = eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"});
    const hoursUntilEta = (eta - now) / 3_600_000;

    let temp = "—", wind = "—", cond = "Forecast beyond range";
    let forecastObj = null;

    if (hoursUntilEta <= noaaHorizonHours) {
      const f = await getNOAAForecast(s.lat, s.lon, eta);
      if (f) {
        temp = f.temperature != null ? `${f.temperature}°F` : "—";
        const speed = f.windSpeed || "", dir = f.windDirection || "";
        wind = (speed || dir) ? `${speed} ${dir}`.trim() : "—";
        cond = f.shortForecast || "—";
        forecastObj = f;
      } else {
        cond = "Forecast unavailable";
      }
    } else if (hoursUntilEta <= openMeteoHorizonHours) {
      const f = await getOpenMeteoForecast(s.lat, s.lon, eta);
      if (f) {
        temp = f.temperature != null ? `${f.temperature}°F` : "—";
        const speed = f.windSpeed || "", dir = f.windDirection || "";
        wind = (speed || dir) ? `${speed} ${dir}`.trim() : "—";
        cond = f.shortForecast || "—";
        forecastObj = f;
      } else {
        cond = "Forecast unavailable";
      }
    } else {
      cond = "Forecast beyond range";
    }

    s.forecastObj = forecastObj;
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${s.name}</td>
      <td>${s.miles.toFixed(1)} mi</td>
      <td>${elapsedStr}</td>
      <td>${timeStr}</td>
      <td>${temp}</td>
      <td>${wind}</td>
      <td>${cond}</td>`;
    tbody.appendChild(row);
    s._row = row;

    s.forecasts = [{ eta, temp, wind, cond, elapsed: elapsedStr }];
  }

  // Update marker tooltips
  if(groupList && groupList.length){
    groupList.forEach(g=>{
      if(g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations));
    });
  }
}
</script>

<!-- ============ Row highlighting ============ -->
<script>
function installRowHighlighting() {
  const attach = (tbody) => {
    if (!tbody) return;
    tbody.addEventListener("pointerup", (e) => {
      const tr = e.target.closest("tr");
      if (!tr) return;
      const table = tr.closest("table");
      const was = tr.classList.contains("highlight-row");
      table.querySelectorAll("tbody tr").forEach(r => r.classList.remove("highlight-row"));
      if (!was) tr.classList.add("highlight-row");
    }, { passive: true });
  };
  attach(document.getElementById("forecastBody"));
  const observer = new MutationObserver(() => {
    document.querySelectorAll(".climoBody").forEach(attach);
  });
  observer.observe(document.getElementById("climatology"), { childList: true, subtree: true });
}
document.addEventListener("DOMContentLoaded", installRowHighlighting);
</script>
</html>
