<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
  <meta charset="UTF-8" />
<meta name="viewport" content="width=1000, user-scalable=yes, initial-scale=1.0, maximum-scale=5.0" />
  <title id="pageTitle">Race Title | Peak Pace</title>

  <!-- Libraries -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
/* Responsive layout with pinch-zoom enabled */
html, body {
  overflow-x: hidden;
  touch-action: pan-x pan-y;
  zoom: 1;
}
    body { margin: 0; padding: 0; font-family: "Source Sans Pro", Arial, sans-serif; color: #111; background: #fff; line-height: 1.5; }

    :root {
      --ink:#111; --muted:#555; --line:#ddd;
      --pp-dark:#003546; --blaze:#37BC7D; --highlight:#FF6700; --hoverRow:#fff3e6;
    }

.page-wrapper {
  width: 1000px;
  margin: 0 auto;
  padding: 0 10px;
  box-sizing: border-box;
}

.main-header {
  text-align: center;
  font-family: "Montserrat", sans-serif;
  font-weight: 800;
  font-size: clamp(36px, 6vw, 52px);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: #000;
  margin: 28px 0 18px;
  line-height: 1;
}
    header { text-align:center; margin:8px auto 14px; }
    header h2 { margin:0; font-size:32px; font-weight:700; }
    #countdown { font-size:20px; font-weight:600; margin-top:6px; color:#333; }

    section, #elevSection { width:100%; margin:18px 0 0 0; border:1px solid #ccc; border-radius:8px; background:#fff; padding:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
    section:last-of-type { margin-bottom:24px; }
    section h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }

    table { width:100%; border-collapse:collapse; }
    th, td { border:1px solid #ccc; padding:8px; text-align:center; font-size:14px; }
    th { background:#f0f0f0; font-weight:700; }
    #climoAvgRow { font-weight:700; background:#f5f5f5; }
    #forecastBody tr:hover, .climoBody tr:hover { background: var(--hoverRow); }
    .note { font-size:12px; text-align:center; margin-top:8px; color:var(--muted); }

    #paceBox { text-align:center; padding:12px; margin:6px 0; background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.08); }
    #paceControls { display:flex; gap:4px; align-items:center; justify-content:center; flex-wrap:wrap; }
    #waveSelectContainer { display:none; margin-bottom:10px; width:100%; justify-content:center; align-items:center; }
    #waveSelect { font-size:14px; padding:6px 10px; margin-left:8px; border-radius:4px; border:1px solid #ccc; min-width:300px; }
    #paceBox select, #paceBox button { font-size:13px; padding:4px 6px; }
    #paceGo, #toggleUnits { border:1px solid var(--pp-dark); border-radius:6px; color:#fff; background:var(--pp-dark); cursor:pointer; }

    #map { width:100%; height:600px; margin:10px 0 0 0; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
    .leaflet-marker-icon { cursor:pointer; transition: transform 150ms ease; }
    .leaflet-marker-icon:hover { transform: scale(1.2); }

    #elevWrap { width:100%; position:relative; height:225px; margin-top:10px; }
    #elevationChart {
      position: absolute;
      inset: 0 17px 0 17px;
      width: calc(100% - 34px) !important;
      height: 100% !important;
      display: block;
      box-sizing: border-box;
    }

    .wbgt-low { color:#2e7d32; } .wbgt-mod { color:#f9a825; }
    .wbgt-high { color:#f57c00; } .wbgt-very { color:#c62828; }
    .wbgt-extreme { background:#ffb3b3; color:#000; font-weight:700; }
    .wbgt-na { color:var(--muted); }

    .blaze-dot { width:20px; height:20px; background:var(--blaze); border:2px solid #222; border-radius:50%; transition:transform 0.2s ease; transform-origin:center; }
    .blaze-dot:hover { transform: scale(1.4); cursor:pointer; }
    .blaze-dot.highlighted { transform: scale(1.6); background: var(--highlight); }

    #forecastBody tr, .climoBody tr {
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .highlight-row {
      background: var(--hoverRow) !important;
      box-shadow: inset 0 0 0 2px var(--highlight);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .leaflet-tooltip, .pp-tooltip { background:#fff; border:2px solid var(--highlight); border-radius:8px; color:var(--ink); font-size:13px; font-weight:500; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:6px 10px; }

    .leaflet-control a { background-color:var(--pp-dark) !important; color:#fff !important; border:1px solid var(--pp-dark) !important; width:30px !important; height:30px !important; line-height:30px !important; text-align:center; font-size:16px; }
    .leaflet-control a:hover { background-color: var(--blaze) !important; border-color: var(--blaze) !important; }

    #climoTabs { display:flex; justify-content:center; margin-bottom:12px; gap:8px; }
    .climoTab { padding:6px 14px; border:1px solid var(--pp-dark); border-radius:6px 6px 0 0; background:#f9f9f9; color:var(--pp-dark); font-size:14px; font-weight:600; cursor:pointer; transition: background 0.2s ease, color 0.2s ease; }
    .climoTab:hover { background: var(--hoverRow); }
    .climoTab.active { background: var(--pp-dark); color:#fff; }
    .climoPanel { display:none; } .climoPanel.active { display:block; }

    .leaflet-container { scroll-margin-top:0; scroll-behavior:auto; }
    .leaflet-container:focus { outline:none; scroll-margin-top:0; }

    section, #map, #paceBox {
      width: 960px;
      max-width: 960px;
      margin: 18px auto;
      box-sizing: border-box;
    }

    #map {
      height: 600px;
      margin-top: 10px;
    }

    #elevSection, #elevWrap {
      width: 960px;
      max-width: 960px;
      margin: 0 auto;
    }
  </style>
</head>

<body>
<div class="page-wrapper">
  <div class="main-header">PEAK PACE WEATHER</div>

  <header>
    <h2 id="raceName"></h2>
    <div id="countdown">Loading countdown…</div>
  </header>

  <!-- Climatology -->
  <section id="climatology">
    <h3 id="climoTitle">Climatology</h3>
    <div id="climoTabs"></div>
    <div id="climoPanels"></div>
  </section>

  <!-- Pace & Wave Selection -->
  <div id="paceBox">
    <!-- Wave Start Time (if enabled) -->
    <div id="waveSelectContainer">
      <label for="waveSelect" style="font-weight:600;">Wave Start Time:</label>
      <select id="waveSelect"></select>
    </div>
    
    <!-- Pace Controls -->
    <div id="paceControls">
      <label for="paceMin" id="paceLabel">Target Pace (min/mi):</label>
      <select id="paceMin"></select> : <select id="paceSec"></select>
      <button id="paceGo">Submit</button>
      <span id="paceConfirm" style="margin-left:8px; font-size:13px; color:var(--muted);"></span>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <!-- Elevation -->
  <section id="elevSection">
    <div id="elevWrap"><canvas id="elevationChart"></canvas></div>
  </section>

  <!-- Summary -->
  <section id="summary">
    <h3 id="tableHeader" style="margin-bottom:0;">Peak Pace Forecast</h3>
    <div id="forecastValidLabel" style="font-size:12px; color:#555; margin:4px 0 6px; text-align:center;">Checking forecast window…</div>
    <table>
      <thead>
        <tr><th>Station</th><th>Distance (mi)</th><th>ETA</th><th>Temp (°F)</th><th>Wind</th><th>Conditions</th><th>WBGT</th></tr>
      </thead>
      <tbody id="forecastBody"></tbody>
    </table>
    <div class="note" id="forecastNote">Forecasts available within 7 days of race.</div>
  </section>

  <!-- Sources -->
  <section id="sources">
    <h3>Data Sources</h3>
    <ul style="font-size:13px; color:#555; line-height:1.5;">
      <li>Climatology: Iowa State University <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">IEM ASOS Archive</a></li>
      <li>Elevation: Mapbox Terrain-RGB</li>
      <li>Weather Forecasts: NOAA/NWS API</li>
      <li>WBGT categories & regional thresholds: NOAA/NWS <a href="https://digital.weather.gov/staticpages/definitions.php" target="_blank" rel="noopener">WBGT Definitions</a></li>
    </ul>
    <div class="note" style="font-size:12px; color:#555; margin-top:6px;">
      WBGT values shown here are <b>approximations</b>, derived from NOAA temperature and relative humidity using the Stull (2011) wet-bulb formula. They represent shaded WBGT and do not fully account for direct sunlight, wind, or radiant heat. On-field measurements may differ.
    </div>
  </section>
</div>
</body>

<script>
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGlsbG9uZHVyaW5pY2siLCJhIjoiY21memtlbm83MDNycTJtb3JtdGxucWpkMiJ9.W7Ge6XYCd0Gfl9f7YQ2dNw";

const raceConfig = {
  name: "TCS NYC Marathon",
  date: new Date("2025-11-02T08:00-05:00"),
  waves: [
    { label: "Men's Professional Wheelchair", time: "08:00" },
    { label: "Women's Professional Wheelchair", time: "08:02" },
    { label: "Handcycle & Select Athletes with Disabilities", time: "08:22" },
    { label: "Professional Women's Open", time: "08:35" },
    { label: "Professional Men's Open", time: "09:05" },
    { label: "Wave 1", time: "09:10" },
    { label: "Wave 2", time: "09:45" },
    { label: "Wave 3", time: "10:20" },
    { label: "Wave 4", time: "10:55" },
    { label: "Wave 5", time: "11:30" }
  ],
  city: "New York, NY",
  climoStationId: "KNYC",
  climoStationName: "NYC Central Park",
  climoBaseUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/",
  routeUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_nyc_marathon_route.json",
  stationsUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_nyc_marathon_stations.json",
  multiDaySpan: 1,
  elevationZoom: 12,
  elevMaxDistance: 26.22,
  mapCenter: [40.7128, -74.0060],
  mapZoom: 12,
  regionCategory: 1
};

document.getElementById("raceName").textContent = raceConfig.name;
document.getElementById("pageTitle").textContent = `${raceConfig.name} | Peak Pace`;
</script>

<script>
function getEffectiveStartTime() {
  if (!raceConfig.waves || raceConfig.waves.length === 0) return raceConfig.date;
  const waveSelect = document.getElementById('waveSelect');
  if (!waveSelect || waveSelect.value === '') return raceConfig.date;
  const selectedWave = raceConfig.waves[parseInt(waveSelect.value)];
  const [hours, minutes] = selectedWave.time.split(':').map(Number);
  const waveDate = new Date(raceConfig.date);
  waveDate.setHours(hours, minutes, 0, 0);
  return waveDate;
}

function updateCountdown() {
  const effectiveStart = getEffectiveStartTime();
  const diff = effectiveStart - new Date();
  const el = document.getElementById("countdown");
  const raceStartStr = effectiveStart.toLocaleString([], { month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
  if (diff <= 0) { el.textContent = "RACE DAY IS HERE!"; return; }
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  el.textContent = days === 1 ? `1 DAY UNTIL RACE DAY (${raceStartStr})` : `${days} DAYS UNTIL RACE DAY (${raceStartStr})`;
}
setInterval(updateCountdown, 60000); 
updateCountdown();

function paceMinPerMiFromUI(){
  const m = Number(document.getElementById('paceMin').value) || 0;
  const s = Number(document.getElementById('paceSec').value) || 0;
  return m + s/60;
}

(function initPaceAndWaves(){
  if (raceConfig.waves && raceConfig.waves.length > 0) {
    const waveContainer = document.getElementById('waveSelectContainer');
    const waveSelect = document.getElementById('waveSelect');
    waveContainer.style.display = 'flex';
    raceConfig.waves.forEach((wave, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = `${wave.time} - ${wave.label}`;
      waveSelect.appendChild(option);
    });
    waveSelect.addEventListener('change', () => {
      updateCountdown();
      if (typeof updateForecasts === 'function') updateForecasts();
    });
  }
  
  const mins=document.getElementById('paceMin'), secs=document.getElementById('paceSec');
  for(let m=4;m<=30;m++){ let o=document.createElement('option'); o.value=m; o.textContent=m; mins.appendChild(o); }
  for(let s=0;s<60;s++){ let o=document.createElement('option'); o.value=s; o.textContent=String(s).padStart(2,'0'); secs.appendChild(o); }
  mins.value=10; secs.value=0;
  
  function showPaceConfirm(){
    const paceM = String(mins.value).padStart(2,"0");
    const paceS = String(secs.value).padStart(2,"0");
    let confirmText = `Pace set to ${paceM}:${paceS} min/mi`;
    if (raceConfig.waves && raceConfig.waves.length > 0) {
      const waveSelect = document.getElementById('waveSelect');
      if (waveSelect && waveSelect.value !== '') {
        const selectedWave = raceConfig.waves[parseInt(waveSelect.value)];
        confirmText += ` | Start: ${selectedWave.time}`;
      }
    }
    document.getElementById("paceConfirm").textContent = confirmText;
  }
  
  const paceBtn = document.getElementById('paceGo');
  paceBtn.addEventListener("mousedown", () => {
    paceBtn.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700';
  });
  paceBtn.addEventListener("mouseup", () => {
    paceBtn.style.backgroundColor = "var(--pp-dark)";
    updateForecasts();
    showPaceConfirm();
  });
  paceBtn.addEventListener("mouseleave", () => { paceBtn.style.backgroundColor = "var(--pp-dark)"; });
  showPaceConfirm();
})();
</script>

<script>
function monthName(d){ return d.toLocaleString('en-US', { month:'long' }); }
function climoFilenameFor(dateObj){
  const mn = monthName(dateObj);
  const day = dateObj.getDate();
  return `${mn}_${day}_Climate.json`;
}
function shortMonthDay(d){ return d.toLocaleString('en-US', { month:'short', day:'numeric' }); }

function populateClimoTable(data, bodyEl, avgRowEl) {
  bodyEl.innerHTML = "";
  let sumMax = 0, sumMin = 0, sumPrecip = 0, count = 0;
  data.forEach(row => {
    const max = Number(row.max);
    const min = Number(row.min);
    const precip = Number(row.precip);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.year}</td>
      <td>${isNaN(max) ? "—" : max.toFixed(1)}</td>
      <td>${isNaN(min) ? "—" : min.toFixed(1)}</td>
      <td>${isNaN(precip) ? "—" : precip.toFixed(2)}</td>
      <td>${row.conditions || "—"}</td>`;
    bodyEl.appendChild(tr);
    if (!isNaN(max)) sumMax += max;
    if (!isNaN(min)) sumMin += min;
    if (!isNaN(precip)) sumPrecip += precip;
    count++;
  });
  if(count > 0){
    avgRowEl.innerHTML = `<td>Averages</td><td>${(sumMax/count).toFixed(1)}</td><td>${(sumMin/count).toFixed(1)}</td><td>${(sumPrecip/count).toFixed(2)}</td><td>—</td>`;
  }
}

function buildClimoPanel(panelId){
  const panel = document.createElement('div');
  panel.className = 'climoPanel';
  panel.id = panelId;
  panel.innerHTML = `
    <table>
      <thead><tr>
        <th>Year</th><th>Max Temp (°F)</th><th>Min Temp (°F)</th>
        <th>Precipitation (")</th><th>Conditions</th>
      </tr></thead>
      <tbody class="climoBody"></tbody>
      <tfoot><tr id="climoAvgRow"><td>Averages</td><td>—</td><td>—</td><td>—</td><td>—</td></tr></tfoot>
    </table>
    <div class="note climoNote"></div>`;
  return panel;
}

async function loadClimatology() {
  const start = new Date(raceConfig.date);
  const span = Math.max(1, Number(raceConfig.multiDaySpan) || 1);
  const climoTitle = document.getElementById('climoTitle');
  const raceDateStr = start.toLocaleDateString([], { month: "short", day: "numeric", year: "numeric" });
  climoTitle.textContent = `Climatology — ${raceConfig.city} (${raceDateStr})`;
  const tabs = document.getElementById('climoTabs');
  const panels = document.getElementById('climoPanels');
  tabs.innerHTML = "";
  panels.innerHTML = "";
  const tabButtons = [];
  for (let i = 0; i < span; i++) {
    const d = new Date(start.getTime() + i * 24 * 60 * 60 * 1000);
    const tab = document.createElement('button');
    tab.className = 'climoTab';
    tab.dataset.dayIndex = String(i);
    tab.textContent = shortMonthDay(d);
    tabButtons.push(tab);
    tabs.appendChild(tab);
    const panel = buildClimoPanel(`climoPanel_${i}`);
    panels.appendChild(panel);
  }
  if (span === 1) { tabs.style.display = 'none'; }
  function activate(idx) {
    panels.querySelectorAll('.climoPanel').forEach(p => p.classList.remove('active'));
    tabButtons.forEach(b => b.classList.remove('active'));
    const p = document.getElementById(`climoPanel_${idx}`);
    if (p) p.classList.add('active');
    if (span > 1 && tabButtons[idx]) tabButtons[idx].classList.add('active');
  }
  if (span > 1) {
    tabButtons.forEach((btn, i) => btn.addEventListener('click', () => activate(i)));
  }
  activate(0);
  for (let i = 0; i < span; i++) {
    const d = new Date(start.getTime() + i * 24 * 60 * 60 * 1000);
    const file = climoFilenameFor(d);
    const url = raceConfig.climoBaseUrl + file;
    const panel = document.getElementById(`climoPanel_${i}`);
    const bodyEl = panel.querySelector('.climoBody');
    const avgRowEl = panel.querySelector('#climoAvgRow');
    const noteEl = panel.querySelector('.climoNote');
    noteEl.textContent = `Historical climatology for ${shortMonthDay(d)} based on ASOS data from ${raceConfig.climoStationId} (${raceConfig.climoStationName}), near ${raceConfig.city}. Local variation may differ from ${raceConfig.climoStationId}. For planning only.`;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error("bad climo response");
      const data = await res.json();
      populateClimoTable(data, bodyEl, avgRowEl);
    } catch (err) {
      console.error('Climo load failed:', file, err);
      bodyEl.innerHTML = `<tr><td colspan="5">Climatology data unavailable for ${shortMonthDay(d)}</td></tr>`;
    }
  }
}
document.addEventListener('DOMContentLoaded', loadClimatology);
</script>

<script>
function latLonToTileXY(lat, lon, z){
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const y = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
  return {x,y};
}

function latLonToPixelXYInTile(lat, lon, z, tileSize=256){
  const n = Math.pow(2, z);
  const xtile = (lon + 180) / 360 * n;
  const latRad = lat * Math.PI/180;
  const ytile = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n;
  const px = Math.floor((xtile - Math.floor(xtile)) * tileSize);
  const py = Math.floor((ytile - Math.floor(ytile)) * tileSize);
  return {px, py};
}

function decodeTerrainRGB(r,g,b){ return -10000 + (r*256*256 + g*256 + b) * 0.1; }

const tileCache = new Map();
async function getTileImageData(z,x,y){
  const key = `${z}/${x}/${y}`;
  if (tileCache.has(key)) return tileCache.get(key);
  const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${MAPBOX_TOKEN}`;
  const img = new Image(); 
  img.crossOrigin = 'anonymous';
  const loaded = new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=(e)=>rej(e); });
  img.src = url; 
  await loaded;
  const canvas = document.createElement('canvas'); 
  canvas.width=256; 
  canvas.height=256;
  const ctx = canvas.getContext('2d'); 
  ctx.drawImage(img,0,0);
  const imageData = ctx.getImageData(0,0,256,256);
  const record = { imageData }; 
  tileCache.set(key, record); 
  return record;
}

async function getElevationMetersAt(lat, lon, z){
  const {x,y} = latLonToTileXY(lat, lon, z);
  const {px,py} = latLonToPixelXYInTile(lat, lon, z, 256);
  try{
    const { imageData } = await getTileImageData(z,x,y);
    const idx = (py*256 + px) * 4;
    const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
    return decodeTerrainRGB(r,g,b);
  }catch(e){ 
    return null; 
  }
}

function haversineMi(a,b){
  const R=3958.7613; 
  const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); 
  const dLon=toRad(b[1]-a[1]); 
  const la1=toRad(a[0]);
  const h=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

let elevChart = null, profileDistances = [], profileElevations = [], currentHighlightIndices = new Set();

function elevationAtMile(mile) {
  if (!profileDistances.length) return null;
  for (let i=1;i<profileDistances.length;i++) {
    if (profileDistances[i] >= mile) {
      const d0 = profileDistances[i-1], d1 = profileDistances[i];
      const e0 = profileElevations[i-1], e1 = profileElevations[i];
      if (e0==null || e1==null) return null;
      const t = (mile-d0)/(d1-d0);
      return e0 + t*(e1-e0);
    }
  }
  return profileElevations[profileElevations.length-1];
}

async function buildElevationProfile(routeCoords, z){
  const fullDistances = [0];
  for(let i=1;i<routeCoords.length;i++) { 
    fullDistances[i] = fullDistances[i-1] + haversineMi(routeCoords[i-1], routeCoords[i]); 
  }
  const sampled = [], sampledDistances = [];
  for (let i=0;i<routeCoords.length;i+=10){ 
    sampled.push(routeCoords[i]); 
    sampledDistances.push(fullDistances[i]); 
  }
  if (sampled[sampled.length-1] !== routeCoords[routeCoords.length-1]) {
    sampled.push(routeCoords[routeCoords.length-1]);
    sampledDistances.push(fullDistances[fullDistances.length-1]);
  }
  const meters=[];
  for (const [lat,lon] of sampled){ 
    meters.push(await getElevationMetersAt(lat,lon,z)); 
  }
  const feet = meters.map(m => (m!=null ? m*3.28084 : null));
  return
