<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Peak Pace Weather — NYC Marathon (WBGT removed, Elapsed Time added) -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
  <title id="pageTitle">Race Title | Peak Pace</title>

  <!-- Fonts & Libraries -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
/* ===== Base + Responsive (pinch-zoom enabled) ===== */
html, body { overflow-x: hidden; touch-action: pan-x pan-y; zoom: 1; }
body { margin: 0; padding: 0; font-family: "Source Sans Pro", Arial, sans-serif; color: #111; background: #fff; line-height: 1.5; }
:root { --ink:#111; --muted:#555; --line:#ddd; --pp-dark:#003546; --blaze:#37BC7D; --highlight:#FF6700; --hoverRow:#fff3e6; }

/* ===== Layout + Header ===== */
.page-wrapper { width: 1000px; margin: 0 auto; padding: 0; box-sizing: border-box; }
.main-header { text-align: center; font-family: "Montserrat", sans-serif; font-weight: 800; font-size: clamp(36px, 6vw, 52px); letter-spacing: .05em; text-transform: uppercase; color: #000; margin: 28px 0 18px; line-height: 1; }
header { text-align:center; margin:8px auto 14px; }
header h2 { margin:0; font-size:32px; font-weight:700; }
#countdown { font-size:20px; font-weight:600; margin-top:6px; color:#333; }

/* ===== Uniform panel widths ===== */
section, #elevSection, #map, #paceBox { width: 960px; max-width: 960px; margin: 18px auto 0; box-sizing: border-box; }
section, #elevSection { border:1px solid #ccc; border-radius:8px; background:#fff; padding:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
section:last-of-type { margin-bottom:24px; }
section h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }

/* Map */
#map { height: 600px; margin-top:10px; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }

/* Elevation */
#elevSection { width: 960px; max-width: 960px; margin: 18px auto; border: 1px solid #ccc; border-radius: 8px; background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.08); padding: 16px; box-sizing: border-box; }
#elevWrap { position:relative; width:100%; height:225px; margin:0 auto; padding:0; box-sizing:border-box; }
#elevationChart { position:absolute; inset:0; width:100% !important; height:100% !important; display:block; box-sizing:border-box; cursor:pointer; }

/* ===== Pace & Wave Control Bar ===== */
#paceBox { text-align:center; padding:10px 12px; margin:10px auto 0; background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.08); }
#paceControls { display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap; }
#paceControls label { font-size:14px; font-weight:600; color:#000; } /* black per preference */
#paceControls select { font-size:13px; border:1px solid var(--pp-dark); border-radius:6px; padding:4px 6px; background:#fff; color:var(--ink); cursor:pointer; min-width:110px; }
#paceControls button { font-size:13px; font-weight:600; border:1px solid var(--pp-dark); border-radius:6px; color:#fff; background:var(--pp-dark); cursor:pointer; padding:6px 10px; transition:background .2s ease; }
#paceControls button:hover { background:var(--highlight); }
#paceConfirm { font-size:13px; color:var(--muted); margin-left:6px; }

/* Tables */
table { width:100%; border-collapse:collapse; }
th, td { border:1px solid #ccc; padding:8px; text-align:center; font-size:14px; }
th { background:#f0f0f0; font-weight:700; }
#climoAvgRow { font-weight:700; background:#f5f5f5; }

/* Hover (desktop) */
#forecastBody tr:hover, .climoBody tr:hover { background: var(--hoverRow); }

/* Tap highlight (mobile & desktop) */
#forecastBody tr, .climoBody tr { cursor: pointer; -webkit-tap-highlight-color: transparent; }
.highlight-row { background: var(--hoverRow) !important; box-shadow: inset 0 0 0 2px var(--highlight); transition: background .2s ease, box-shadow .2s ease; }

.note { font-size:12px; text-align:center; margin-top:8px; color:var(--muted); }

/* Leaflet styles & tooltips */
.leaflet-marker-icon { cursor:pointer; transition: transform 150ms ease; }
.leaflet-marker-icon:hover { transform: scale(1.2); }
.leaflet-tooltip, .pp-tooltip { background:#fff; border:2px solid var(--highlight); border-radius:8px; color:var(--ink); font-size:13px; font-weight:500; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:6px 10px; }
.leaflet-control a { background-color:var(--pp-dark) !important; color:#fff !important; border:1px solid var(--pp-dark) !important; width:30px !important; height:30px !important; line-height:30px !important; text-align:center; font-size:16px; }
.leaflet-control a:hover { background-color: var(--blaze) !important; border-color: var(--blaze) !important; }

/* Blaze markers */
.blaze-dot { width:20px; height:20px; background:var(--blaze); border:2px solid #222; border-radius:50%; transition:transform .2s ease; transform-origin:center; }
.blaze-dot:hover { transform: scale(1.4); cursor:pointer; }
.blaze-dot.highlighted { transform: scale(1.6); background: var(--highlight); }

/* Climo tabs (auto-hidden for 1 day) */
#climoTabs { display:flex; justify-content:center; margin-bottom:12px; gap:8px; }
.climoTab { padding:6px 14px; border:1px solid var(--pp-dark); border-radius:6px 6px 0 0; background:#f9f9f9; color:var(--pp-dark); font-size:14px; font-weight:600; cursor:pointer; transition: background .2s ease, color .2s ease; }
.climoTab:hover { background: var(--hoverRow); }
.climoTab.active { background: var(--pp-dark); color:#fff; }
.climoPanel { display:none; }
.climoPanel.active { display:block; }

/* Prevent focus-snap on Leaflet */
.leaflet-container { scroll-margin-top:0; scroll-behavior:auto; }
.leaflet-container:focus { outline:none; scroll-margin-top:0; }
  
/* ==== Pace Box Styling ==== */
#paceBox {
  padding: 20px 24px;
  margin: 18px auto;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.08);
  width: 960px;
  max-width: 960px;
}
#waveRow, #paceRow {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
}
#waveRow {
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid #eee;
}
#paceRow {
  flex-wrap: wrap;
}
#waveRow label, #paceRow label {
  font-weight: 700;
  color: #000;
  font-size: 15px;
}
#paceBox select {
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 6px;
  background: #fff;
  color: #111;
  padding: 8px 12px;
  cursor: pointer;
  height: 38px;
}
#waveSelect {
  min-width: 380px;
}
#paceMin, #paceSec {
  min-width: 65px;
  width: 65px;
}
.pace-input-group {
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.pace-input-group span {
  color: #666;
  font-size: 16px;
  font-weight: 700;
}
#paceGo {
  font-size: 14px;
  font-weight: 600;
  border: 1px solid #003546;
  border-radius: 6px;
  color: #fff;
  background: #003546;
  cursor: pointer;
  padding: 9px 20px;
  height: 38px;
  transition: background 0.2s ease;
  margin-left: 4px;
}
#paceGo:hover { background: #FF6700; }
#paceConfirm {
  font-size: 14px;
  color: #888;
  margin-left: 12px;
  font-style: italic;
}
#paceConfirm.success {
  color: #37BC7D;
  font-style: normal;
  font-weight: 500;
}

</style>
</head>

<body>
  <div class="page-wrapper">
    <div class="main-header">PEAK PACE WEATHER</div>

    <header>
      <h2 id="raceName"></h2>
      <div id="countdown">Loading countdown…</div>
    </header>

    <!-- ============ Climatology (date-driven) ============ -->
    <section id="climatology">
      <h3 id="climoTitle">Climatology</h3>
      <div id="climoTabs"></div>
      <div id="climoPanels"></div>
    </section>

    <!-- Pace -->
    <div id="paceBox">
      <div id="waveRow">
        <label for="waveSelect">Wave Start Time:</label>
        <select id="waveSelect"></select>
      </div>
      <div id="paceRow">
        <label for="paceMin">Target Pace (min/mi):</label>
        <div class="pace-input-group">
          <select id="paceMin"></select>
          <span>:</span>
          <select id="paceSec"></select>
        </div>
        <button id="paceGo">Generate Peak Pace Forecast</button>
        <span id="paceConfirm">Select wave start time and input target pace.</span>
      </div>
    </div>

    <!-- Map -->
    <div id="map"></div>

    <!-- Elevation -->
    <section id="elevSection">
      <div id="elevWrap"><canvas id="elevationChart"></canvas></div>
    </section>

    <!-- Forecast Summary -->
    <section id="summary">
      <h3 id="tableHeader" style="margin-bottom:14px;">Peak Pace Forecast</h3>
      <table>
        <thead>
          <tr><th>Station</th><th>Distance (mi)</th><th>Elapsed</th><th>ETA</th><th>Temp (°F)</th><th>Wind</th><th>Conditions</th></tr>
        </thead>
        <tbody id="forecastBody">
          <tr id="forecastPlaceholder">
            <td colspan="7" style="text-align:center; padding:40px 20px; color:#888; font-style:italic;">
              Select wave start time and input target pace to generate Peak Pace Forecast
            </td>
          </tr>
        </tbody>
      </table>
      <div style="text-align:center; font-size:12px; color:#555; margin-top:12px;">
        <span id="forecastValidLabel"></span>
        <br>
        <span id="sourceLabel" style="color:#777;"></span>
      </div>
    </section>

    <!-- Sources -->
    <section id="sources">
      <h3>Data Sources</h3>
      <ul style="font-size:13px; color:#555; line-height:1.5;">
        <li>Climatology: Iowa State University <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">IEM ASOS Archive</a></li>
        <li>Elevation: Mapbox Terrain-RGB</li>
        <li>Weather Forecasts: NOAA/NWS API</li>
      </ul>
    </section>
  </div>
</body>

<!-- ============ CONFIG (Edit this block only) ============ -->
<script>
/* Keep this token as requested */
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGlsbG9uZHVyaW5pY2siLCJhIjoiY21memtlbm83MDNycTJtb3JtdGxucWpkMiJ9.W7Ge6XYCd0Gfl9f7YQ2dNw";

/* ====== EDIT ME FOR EACH RACE ======
name:             Display name
date:             Base date (we'll apply wave offsets on change)
city:             City label for climatology section title
climoStationId:   ASOS/airport code used for climatology note
climoStationName: Friendly station name used for note
climoBaseUrl:     Base URL where monthly/day JSON lives
routeUrl:         Raw JSON (array of [lat,lon])
stationsUrl:      Raw JSON ({ name, lat, lon, miles }[])
multiDaySpan:     Number of race days (1 = no tabs; >1 auto-tabs)
elevationZoom:    Terrain-RGB zoom for elevation sampling
===================================== */
const raceConfig = {
  name: "TCS New York City Marathon",
  date: new Date("2025-11-02T08:00:00-05:00"), // base; wave menu will override time
  city: "New York, NY",
  climoStationId: "KNYC",
  climoStationName: "New York Central Park",
  climoBaseUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/",
  routeUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/main/2025_nyc_marathon_route.json",
  stationsUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/main/2025_nyc_marathon_stations.json",
  multiDaySpan: 1,
  elevationZoom: 13,
  routeSampleStep: 20
};

document.getElementById("raceName").textContent = raceConfig.name;
document.getElementById("pageTitle").textContent = `${raceConfig.name} | Peak Pace`;
</script>

<!-- ============ COUNTDOWN, PACE & WAVES ============ -->
<script>
function updateCountdown() {
  const diff = raceConfig.date - new Date();
  const el = document.getElementById("countdown");
  const raceDateStr = raceConfig.date.toLocaleString([], { month:"long", day:"numeric", year:"numeric" });
  if (diff <= 0) { el.textContent = `${raceDateStr} (RACE DAY IS HERE!)`; return; }
  
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  
  let countdownText = "";
  if (days > 0) {
    countdownText = `${days} ${days === 1 ? 'Day' : 'Days'}`;
  }
  if (hours > 0 || days > 0) {
    if (days > 0) countdownText += " and ";
    countdownText += `${hours} ${hours === 1 ? 'Hour' : 'Hours'}`;
  }
  countdownText += " Until Race Day";
  
  el.textContent = `${raceDateStr} (${countdownText})`;
}
setInterval(updateCountdown, 60000);
updateCountdown();

function paceMinPerMiFromUI(){
  const m = Number(document.getElementById('paceMin').value) || 0;
  const s = Number(document.getElementById('paceSec').value) || 0;
  return m + s/60;
}
function formatElapsedFromMinutes(mins){
  const totalSeconds = Math.round(mins * 60);
  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
(function initPace(){
  const mins=document.getElementById('paceMin'), secs=document.getElementById('paceSec');
  for(let m=4;m<=30;m++){ let o=document.createElement('option'); o.value=m; o.textContent=m; mins.appendChild(o); }
  for(let s=0;s<60;s++){ let o=document.createElement('option'); o.value=s; o.textContent=String(s).padStart(2,'0'); secs.appendChild(o); }
  mins.value=10; secs.value=0;

  const paceBtn = document.getElementById('paceGo');
  function showPaceConfirm(){
    const paceM = String(mins.value).padStart(2,"0");
    const paceS = String(secs.value).padStart(2,"0");
    
    // Get start time in 12-hour format
    const startTimeStr = raceConfig.date.toLocaleTimeString([], { hour:"numeric", minute:"2-digit" }).toLowerCase();
    
    const confirmEl = document.getElementById("paceConfirm");
    confirmEl.textContent = `Start time: ${startTimeStr} | Target pace: ${paceM}:${paceS} min/mi`;
    confirmEl.classList.add('success');
  }
  // Button feedback: “Updating…” for ~1s
  paceBtn.addEventListener("mousedown", () => {
    paceBtn.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700';
  });
  paceBtn.addEventListener("mouseup", async () => {
    paceBtn.style.backgroundColor = "var(--pp-dark)";
    
    // Set loading cursor
    document.body.style.cursor = "wait";
    paceBtn.style.cursor = "wait";
    
    const label = document.getElementById("forecastValidLabel");
    const prev = label.textContent;
    label.textContent = "Fetching forecast…";
    
    await new Promise(r => setTimeout(r, 1000)); // 1s hold
    await updateForecasts();
    
    // Reset cursor
    document.body.style.cursor = "default";
    paceBtn.style.cursor = "pointer";
    
    label.textContent = prev.includes("Fetching") ? "" : label.textContent;
    showPaceConfirm();
  });
  paceBtn.addEventListener("mouseleave", () => { paceBtn.style.backgroundColor = "var(--pp-dark)"; });
  // No confirmation on initial load - only after user clicks
})();

/* ===== Wave Start Selection (NYC Marathon) ===== */
(function initWaveSelect(){
  const waveSelect = document.getElementById("waveSelect");
  const waves = [
    {label:"Professional Wheelchair Division – Men: 8:00 AM", offset:"08:00"},
    {label:"Professional Wheelchair Division – Women: 8:02 AM", offset:"08:02"},
    {label:"Handcycle Category & Select Athletes with Disabilities: 8:22 AM", offset:"08:22"},
    {label:"Professional Women’s Open Division: 8:35 AM", offset:"08:35"},
    {label:"Professional Men’s Open Division: 9:05 AM", offset:"09:05"},
    {label:"Wave 1 Start: 9:10 AM", offset:"09:10"},
    {label:"Wave 2 Start: 9:45 AM", offset:"09:45"},
    {label:"Wave 3 Start: 10:20 AM", offset:"10:20"},
    {label:"Wave 4 Start: 10:55 AM", offset:"10:55"},
    {label:"Wave 5 Start: 11:30 AM", offset:"11:30"}
  ];
  waves.forEach(w => { const opt=document.createElement("option"); opt.textContent=w.label; opt.value=w.offset; waveSelect.appendChild(opt); });
  waveSelect.value = "09:10"; // default Wave 1

  // Styling (matches pace selects)
  Object.assign(waveSelect.style, { border:"1px solid var(--pp-dark)", borderRadius:"6px", padding:"4px 6px", fontSize:"13px", color:"var(--ink)", background:"#fff", cursor:"pointer" });

  function updateWaveStart(){
    const [hh, mm] = (waveSelect.value||"08:00").split(":").map(Number);
    const base = new Date(raceConfig.date);
    base.setHours(hh, mm, 0, 0);
    raceConfig.date = base;
    
    updateCountdown();
    // Forecast now only updates on button click
  }
  waveSelect.addEventListener("change", updateWaveStart);
  updateWaveStart(); // Initialize
})();
</script>

<!-- ============ CLIMATOLOGY (date-driven) ============ -->
<script>
function monthName(d){ return d.toLocaleString('en-US', { month:'long' }); }
function climoFilenameFor(dateObj){ const mn = monthName(dateObj); const day = dateObj.getDate(); return `${mn}_${day}_Climate.json`; }
function shortMonthDay(d){ return d.toLocaleString('en-US', { month:'short', day:'numeric' }); }

function populateClimoTable(data, bodyEl, avgRowEl){
  bodyEl.innerHTML = "";
  let sumMax=0, sumMin=0, sumP=0, n=0;
  data.forEach(row => {
    const max = Number(row.max), min = Number(row.min);
    // Handle "T" for trace precipitation
    let precipDisplay, precipValue;
    console.log(`Year ${row.year}: precip raw value = "${row.precip}", type = ${typeof row.precip}`);
    if (row.precip === "T" || row.precip === "t") {
      precipDisplay = "T";
      precipValue = 0; // Count as 0 for averaging
    } else {
      precipValue = Number(row.precip);
      precipDisplay = isNaN(precipValue) ? "—" : precipValue.toFixed(2);
    }
    
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.year}</td>
      <td>${isNaN(max) ? "—" : max.toFixed(1)}</td>
      <td>${isNaN(min) ? "—" : min.toFixed(1)}</td>
      <td>${precipDisplay}</td>
      <td>${row.conditions || "—"}</td>`;
    bodyEl.appendChild(tr);
    if(!isNaN(max)) sumMax+=max;
    if(!isNaN(min)) sumMin+=min;
    if(!isNaN(precipValue)) sumP+=precipValue;
    n++;
  });
  if(n>0){
    avgRowEl.innerHTML = `<td>Averages</td>
      <td>${(sumMax/n).toFixed(1)}</td>
      <td>${(sumMin/n).toFixed(1)}</td>
      <td>${(sumP/n).toFixed(2)}</td>
      <td>—</td>`;
  }
}

function buildClimoPanel(panelId){
  const panel = document.createElement('div');
  panel.className = 'climoPanel';
  panel.id = panelId;
  panel.innerHTML = `
    <table>
      <thead><tr>
        <th>Year</th><th>Max Temp (°F)</th><th>Min Temp (°F)</th>
        <th>Precipitation (")</th><th>Conditions</th>
      </tr></thead>
      <tbody class="climoBody"></tbody>
      <tfoot><tr id="climoAvgRow"><td>Averages</td><td>—</td><td>—</td><td>—</td><td>—</td></tr></tfoot>
    </table>
    <div class="note climoNote"></div>`;
  return panel;
}

async function loadClimatology() {
  const start = new Date(raceConfig.date);
  const span = Math.max(1, Number(raceConfig.multiDaySpan) || 1);

  const climoTitle = document.getElementById('climoTitle');
  const raceDateStr = start.toLocaleDateString([], { month:"long", day:"numeric" });
  climoTitle.textContent = `Climatology – ${raceDateStr} – ${raceConfig.city}`;

  const tabs = document.getElementById('climoTabs');
  const panels = document.getElementById('climoPanels');
  tabs.innerHTML = ""; panels.innerHTML = "";

  const tabButtons = [];
  for (let i = 0; i < span; i++) {
    const d = new Date(start.getTime() + i*24*60*60*1000);
    const tab = document.createElement('button');
    tab.className = 'climoTab';
    tab.dataset.dayIndex = String(i);
    tab.textContent = shortMonthDay(d);
    tabButtons.push(tab);
    tabs.appendChild(tab);

    const panel = buildClimoPanel(`climoPanel_${i}`);
    panels.appendChild(panel);
  }

  if (span === 1) { tabs.style.display = 'none'; }

  function activate(idx){
    panels.querySelectorAll('.climoPanel').forEach(p => p.classList.remove('active'));
    tabButtons.forEach(b => b.classList.remove('active'));
    const p = document.getElementById(`climoPanel_${idx}`);
    if (p) p.classList.add('active');
    if (span>1 && tabButtons[idx]) tabButtons[idx].classList.add('active');
  }
  if (span>1) tabButtons.forEach((btn,i)=>btn.addEventListener('click',()=>activate(i)));
  activate(0);

  for (let i=0; i<span; i++){
    const d = new Date(start.getTime() + i*24*60*60*1000);
    const file = climoFilenameFor(d);
    const url = raceConfig.climoBaseUrl + file;

    const panel = document.getElementById(`climoPanel_${i}`);
    const bodyEl = panel.querySelector('.climoBody');
    const avgRowEl = panel.querySelector('#climoAvgRow');
    const noteEl = panel.querySelector('.climoNote');

    noteEl.textContent = `Historical climatology for ${shortMonthDay(d)} based on ASOS data from ${raceConfig.climoStationId} (${raceConfig.climoStationName}), near ${raceConfig.city}. Local variation may differ from ${raceConfig.climoStationId}. For planning only.`;

    try{
      const res = await fetch(url);
      if(!res.ok) throw new Error("bad climo response");
      const data = await res.json();
      populateClimoTable(data, bodyEl, avgRowEl);
    }catch(err){
      console.error('Climo load failed:', file, err);
      bodyEl.innerHTML = `<tr><td colspan="5">Climatology data unavailable for ${shortMonthDay(d)}</td></tr>`;
    }
  }
}
document.addEventListener('DOMContentLoaded', loadClimatology);
</script>

<!-- ============ TERRAIN + ELEVATION ============ -->
<script>
function latLonToTileXY(lat, lon, z){
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const y = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
  return {x,y};
}
function latLonToPixelXYInTile(lat, lon, z, tileSize=256){
  const n = Math.pow(2, z);
  const xtile = (lon + 180) / 360 * n;
  const latRad = lat * Math.PI/180;
  const ytile = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n;
  const px = Math.floor((xtile - Math.floor(xtile)) * tileSize);
  const py = Math.floor((ytile - Math.floor(ytile)) * tileSize);
  return {px, py};
}
function decodeTerrainRGB(r,g,b){ return -10000 + (r*256*256 + g*256 + b) * 0.1; }

const tileCache = new Map();
async function getTileImageData(z,x,y){
  const key = `${z}/${x}/${y}`;
  if (tileCache.has(key)) return tileCache.get(key);
  const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${MAPBOX_TOKEN}`;
  const img = new Image(); img.crossOrigin = 'anonymous';
  const loaded = new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=(e)=>rej(e); });
  img.src = url; await loaded;
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
  const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
  const imageData = ctx.getImageData(0,0,256,256);
  const record = { imageData }; tileCache.set(key, record); return record;
}
async function getElevationMetersAt(lat, lon, z){
  const {x,y} = latLonToTileXY(lat, lon, z);
  const {px,py} = latLonToPixelXYInTile(lat, lon, z, 256);
  try{
    const { imageData } = await getTileImageData(z,x,y);
    const idx = (py*256 + px) * 4;
    const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
    return decodeTerrainRGB(r,g,b);
  }catch(e){ return null; }
}
function haversineMi(a,b){
  const R=3958.7613; const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLon=toRad(b[1]-a[1]); const la1=toRad(a[0]);
  const h=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

let elevChart = null, profileDistances = [], profileElevations = [], currentHighlightIndices = new Set();
function elevationAtMile(mile) {
  if (!profileDistances.length) return null;
  for (let i=1;i<profileDistances.length;i++) {
    if (profileDistances[i] >= mile) {
      const d0 = profileDistances[i-1], d1 = profileDistances[i];
      const e0 = profileElevations[i-1], e1 = profileElevations[i-1] == null ? null : profileElevations[i];
      if (e0==null || e1==null) return null;
      const t = (mile-d0)/(d1-d0);
      return e0 + t*(e1-e0);
    }
  }
  return profileElevations[profileElevations.length-1];
}
async function buildElevationProfile(routeCoords, z){
  const fullDistances = [0];
  for(let i=1;i<routeCoords.length;i++) fullDistances[i] = fullDistances[i-1] + haversineMi(routeCoords[i-1], routeCoords[i]);
  const sampled = [], sampledDistances = [];
  for (let i=0;i<routeCoords.length;i+=10){ sampled.push(routeCoords[i]); sampledDistances.push(fullDistances[i]); }
  if (sampled[sampled.length-1] !== routeCoords[routeCoords.length-1]) {
    sampled.push(routeCoords[routeCoords.length-1]);
    sampledDistances.push(fullDistances[fullDistances.length-1]);
  }
  const meters=[];
  for (const [lat,lon] of sampled){ meters.push(await getElevationMetersAt(lat,lon,z)); }
  const feet = meters.map(m => (m!=null ? m*3.28084 : null));
  return { distances: sampledDistances, elevations: feet, sampled };
}
function buildElevationChart(distances, elevations, stations){
  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevChart) elevChart.destroy();
  profileDistances = distances; profileElevations = elevations;
  const stationPoints = stations.map(s => ({ x: s.miles, y: elevationAtMile(s.miles) }));
  elevChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label:'Elevation', data: profileDistances.map((d,i)=>({x:d,y:elevations[i]})), parsing:false, borderColor:'#000', pointRadius:0, borderWidth:1.5, fill:false, tension:0.1 },
        {
          label:'Aid Stations', type:'scatter', data: stationPoints, parsing:false, pointRadius:6, hoverRadius:10, hitRadius:12,
          pointBackgroundColor: (c) => {
            const idx = c.dataIndex;
            return (elevChart && currentHighlightIndices.has(idx))
              ? getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700'
              : getComputedStyle(document.documentElement).getPropertyValue('--blaze').trim() || '#37BC7D';
          },
          pointBorderColor:'#222', pointBorderWidth:1
        }
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } },
      plugins: {
        legend: { display:false },
        tooltip: {
          enabled:true, filter: ctx => ctx.datasetIndex === 1,
          callbacks: {
            title: (ctx) => {
              const station = stations[ctx[0].dataIndex];
              return `${station.name} – Mile ${station.miles.toFixed(1)}`;
            },
            label: (ctx) => {
              const station = stations[ctx.dataIndex];
              const pace = paceMinPerMiFromUI();
              const elapsed = formatElapsedFromMinutes(station.miles * pace);
              if (station.forecasts && station.forecasts.length) {
                return station.forecasts.map(f => [
                  `Elapsed: ${elapsed}`,
                  `ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}`,
                  `Temp: ${f.temp}`, `Wind: ${f.wind}`, `Conditions: ${f.cond}`
                ]).flat();
              }
              return [`Elapsed: ${elapsed}`, "Forecast: —"];
            }
          },
          backgroundColor:'#fff',
          borderColor: getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700',
          borderWidth:2, titleColor:'#111', bodyColor:'#111', padding:8, displayColors:false
        }
      },
      interaction: { mode:'point', intersect:true },
      onHover: (event, elements) => {
        const canvas = event.chart.canvas;
        if (elements.length > 0 && elements[0].datasetIndex === 1) {
          canvas.style.cursor = 'pointer';
          const idx = elements[0].index;
          highlightByStationIndex(idx);
        } else {
          canvas.style.cursor = 'default';
          clearHighlights();
          event.chart.tooltip.setActiveElements([], {x:0,y:0});
          event.chart.update();
        }
      },
      scales: {
        x: { type:'linear', title:{ display:true, text:'Distance (mi)' }, min:0, max:26.2 },
        y: { title:{ display:true, text:'Elevation (ft)' }, ticks:{ autoSkip:true, maxTicksLimit:6 } }
      }
    }
  });
  ctx.canvas.addEventListener("mouseleave", () => {
    if (elevChart) {
      elevChart.tooltip.setActiveElements([], {x:0,y:0});
      elevChart.update();
      clearHighlights();
    }
  });
}
</script>

<!-- ============ MAP + MARKERS + FORECASTS ============ -->
<script>
function daysUntilRace(){return Math.floor((raceConfig.date-new Date())/(1000*60*60*24));}

/* NOAA */
async function getNOAAForecast(lat, lon, targetDate) {
  try {
    const pointRes = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    const pointData = await pointRes.json();
    const fRes = await fetch(pointData.properties.forecastHourly);
    const fData = await fRes.json();
    const periods=fData?.properties?.periods||[];
    if (!periods.length) return null;
    return periods.reduce((p,c)=>
      Math.abs(new Date(c.startTime)-targetDate) < Math.abs(new Date(p.startTime)-targetDate) ? c : p
    );
  } catch { return null; }
}

async function getOpenMeteoForecast(lat, lon, targetDate) {
  try {
    // OpenMeteo API: free, no key required, 16-day hourly forecast
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,wind_speed_10m,wind_direction_10m,weather_code&temperature_unit=fahrenheit&wind_speed_unit=mph&timezone=auto`;
    const res = await fetch(url);
    const data = await res.json();
    
    if (!data.hourly || !data.hourly.time) return null;
    
    // Find closest time to target
    const times = data.hourly.time.map(t => new Date(t));
    let closestIdx = 0;
    let minDiff = Math.abs(times[0] - targetDate);
    
    for (let i = 1; i < times.length; i++) {
      const diff = Math.abs(times[i] - targetDate);
      if (diff < minDiff) {
        minDiff = diff;
        closestIdx = i;
      }
    }
    
    // Convert weather code to description
    const weatherCode = data.hourly.weather_code[closestIdx];
    const weatherDescriptions = {
      0: "Clear", 1: "Mainly Clear", 2: "Partly Cloudy", 3: "Overcast",
      45: "Foggy", 48: "Depositing Rime Fog",
      51: "Light Drizzle", 53: "Moderate Drizzle", 55: "Dense Drizzle",
      56: "Light Freezing Drizzle", 57: "Dense Freezing Drizzle",
      61: "Slight Rain", 63: "Moderate Rain", 65: "Heavy Rain",
      66: "Light Freezing Rain", 67: "Heavy Freezing Rain",
      71: "Slight Snow", 73: "Moderate Snow", 75: "Heavy Snow",
      77: "Snow Grains",
      80: "Slight Rain Showers", 81: "Moderate Rain Showers", 82: "Violent Rain Showers",
      85: "Slight Snow Showers", 86: "Heavy Snow Showers",
      95: "Thunderstorm", 96: "Thunderstorm with Slight Hail", 99: "Thunderstorm with Heavy Hail"
    };
    
    const temp = data.hourly.temperature_2m[closestIdx];
    const windSpeed = data.hourly.wind_speed_10m[closestIdx];
    const windDir = data.hourly.wind_direction_10m[closestIdx];
    
    // Convert wind direction degrees to cardinal direction
    const windDirCardinal = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(windDir / 22.5) % 16];
    
    return {
      temperature: Math.round(temp),
      windSpeed: `${Math.round(windSpeed)} mph`,
      windDirection: windDirCardinal,
      shortForecast: weatherDescriptions[weatherCode] || "Unknown"
    };
  } catch (err) {
    console.error('OpenMeteo error:', err);
    return null;
  }
}

function bindMarkerTooltip(marker) {
  marker.bindTooltip("", { direction: "auto", offset: [0, -10], opacity: 0.95, className: "pp-tooltip", sticky: false, autoPan: true });
}

/* Map (center on Verrazzano-Narrows Bridge) */
const map = L.map('map', {
  keyboard: false,
  scrollWheelZoom: false,
  touchZoom: 'center',
  zoomControl: true,
  dragging: true
}).setView([40.6066, -74.0447], 12);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

/* Globals */
let markers = [];
let groupList = [];
let stationIndexToGroup = [];

function applyMarkerHighlights(activeGroupIdx){
  markers.forEach((m,i)=>{ const dot = m.getElement()?.querySelector('.blaze-dot'); if (dot) dot.classList.toggle("highlighted", i === activeGroupIdx); });
}
function applyChartHighlights(indices){
  currentHighlightIndices = new Set(indices);
  if (elevChart){ elevChart.setActiveElements(indices.map(i=>({datasetIndex:1,index:i}))); elevChart.update(); }
}
function highlightByStationIndex(stationIdx){
  const gIdx = stationIndexToGroup[stationIdx];
  applyMarkerHighlights(gIdx);
  applyChartHighlights([stationIdx]);
}
function highlightByGroupIndex(groupIdx){
  const indices = groupList[groupIdx].indices;
  applyMarkerHighlights(groupIdx);
  applyChartHighlights(indices);
}
function clearHighlights(){
  currentHighlightIndices.clear();
  markers.forEach(m=>m.getElement()?.querySelector('.blaze-dot')?.classList.remove("highlighted"));
  if(elevChart){ elevChart.setActiveElements([]); elevChart.update(); }
}
const blazeIcon = L.divIcon({ className:"", html:'<div class="blaze-dot"></div>', iconSize:[20,20], iconAnchor:[10,10] });

function tooltipLinesMapGroup(g, stations) {
  let html = "";
  g.indices.forEach((i, idx) => {
    const s = stations[i];
    if (idx > 0) html += `<hr style="margin:6px 0;">`
    const pace = paceMinPerMiFromUI();
    const elapsed = formatElapsedFromMinutes(s.miles * pace);
    html += `<div style="margin-bottom:6px;">
      <strong>${s.name} – Mile ${s.miles.toFixed(1)}</strong><br>`;
    if (s.forecasts && s.forecasts.length) {
      s.forecasts.forEach(f => {
        html += `Elapsed: ${elapsed}<br>
                 ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}<br>
                 Temp: ${f.temp}<br>
                 Wind: ${f.wind}<br>
                 Conditions: ${f.cond}<br>`;
      });
    } else {
      html += `Elapsed: ${elapsed}<br>Forecast: —<br>`;
    }
    html += `</div>`;
  });
  return html;
}

/* Build everything */
Promise.all([
  fetch(raceConfig.routeUrl).then(r=>r.json()),
  fetch(raceConfig.stationsUrl).then(r=>r.json())
]).then(async([route,stations])=>{
  raceConfig.route=route; raceConfig.stations=stations;

  const line=L.polyline(route,{color:"#000",weight:3}).addTo(map);
  map.fitBounds(line.getBounds());

  // Elevation
  try{
    const {distances,elevations}=await buildElevationProfile(route,raceConfig.elevationZoom);
    buildElevationChart(distances,elevations,stations);
  }catch(e){
    console.error('Elevation error',e);
    const distances=[0];
    for(let i=1;i<route.length;i++) distances[i]=distances[i-1]+haversineMi(route[i-1],route[i]);
    const elevations=distances.map(()=>1500);
    buildElevationChart(distances,elevations,stations);
  }

  // Group stations that share a lat/lon
  const groupsByKey = {};
  stations.forEach((s, idx) => {
    const key = `${s.lat},${s.lon}`;
    if (!groupsByKey[key]) groupsByKey[key] = { lat:s.lat, lon:s.lon, indices:[] };
    groupsByKey[key].indices.push(idx);
  });
  groupList = Object.values(groupsByKey);

  // Place markers
  groupList.forEach((g, gIdx) => {
    g.indices.forEach(stIdx => { stationIndexToGroup[stIdx] = gIdx; });
    const marker = L.marker([g.lat, g.lon], { icon: blazeIcon }).addTo(map);
    g.marker = marker;
    markers.push(marker);
    bindMarkerTooltip(marker);
    marker.setTooltipContent(tooltipLinesMapGroup(g, stations));
    marker.on("mouseover", () => highlightByGroupIndex(gIdx));
    marker.on("mouseout", clearHighlights);
  });

  // Forecast now loads on demand via "Fetch Forecast" button
  // groupList.forEach(g => { if (g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations)); });
});

/* Forecast table + updates */
async function updateForecasts(){
  const tbody = document.getElementById("forecastBody");
  const validLabel = document.getElementById("forecastValidLabel");
  const sourceLabel = document.getElementById("sourceLabel");
  tbody.innerHTML = "";

  const pace = paceMinPerMiFromUI();
  const now = new Date();
  const noaaHorizonHours = 6.5 * 24;
  const openMeteoHorizonHours = 16 * 24;

  // Determine global window message by checking min ETA horizon
  let minHrs = Infinity;
  for (const s of (raceConfig.stations || [])){
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const hrs = (eta - now) / 3_600_000;
    if (hrs < minHrs) minHrs = hrs;
  }

  // Update source label based on which API will be used
  if (minHrs <= noaaHorizonHours) {
    validLabel.textContent = `Forecast valid as of ${new Date().toLocaleString()}`;
    sourceLabel.textContent = `Source: NOAA forecastHourly`;
  } else if (minHrs <= openMeteoHorizonHours) {
    validLabel.textContent = `Forecast valid as of ${new Date().toLocaleString()}`;
    sourceLabel.textContent = `Source: Open-Meteo`;
  } else {
    validLabel.textContent = ``;
    sourceLabel.textContent = ``;
  }

  for (const s of (raceConfig.stations || [])){
    const elapsedStr = formatElapsedFromMinutes(s.miles * pace);
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const timeStr = eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"});
    const hoursUntilEta = (eta - now) / 3_600_000;

    // Defaults
    let temp = "—", wind = "—", cond = "Forecast beyond range";
    let forecastObj = null;

    // Tiered approach: NOAA (0-6.5 days) -> OpenMeteo (6.5-16 days) -> Beyond range
    if (hoursUntilEta <= noaaHorizonHours) {
      const f = await getNOAAForecast(s.lat, s.lon, eta);
      if (f) {
        temp = f.temperature != null ? `${f.temperature}°F` : "—";
        const speed = f.windSpeed || "", dir = f.windDirection || "";
        wind = (speed || dir) ? `${speed} ${dir}`.trim() : "—";
        cond = f.shortForecast || "—";
        forecastObj = f;
      } else {
        cond = "Forecast unavailable";
      }
    } else if (hoursUntilEta <= openMeteoHorizonHours) {
      const f = await getOpenMeteoForecast(s.lat, s.lon, eta);
      if (f) {
        temp = f.temperature != null ? `${f.temperature}°F` : "—";
        const speed = f.windSpeed || "", dir = f.windDirection || "";
        wind = (speed || dir) ? `${speed} ${dir}`.trim() : "—";
        cond = f.shortForecast || "—";
        forecastObj = f;
      } else {
        cond = "Forecast unavailable";
      }
    } else {
      cond = "Forecast beyond range";
    }

    s.forecastObj = forecastObj;
    const row=document.createElement("tr");
    row.innerHTML=`
      <td>${s.name}</td>
      <td>${s.miles.toFixed(1)} mi</td>
      <td>${elapsedStr}</td>
      <td>${timeStr}</td>
      <td>${temp}</td>
      <td>${wind}</td>
      <td>${cond}</td>`;
    tbody.appendChild(row);
    s._row=row;

    s.forecasts=[{ eta,temp,wind,cond, elapsed: elapsedStr }];
  }

  // Update marker tooltips with fresh table data
  if(groupList && groupList.length){
    groupList.forEach(g=>{
      if(g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations));
    });
  }

  // Note: forecastNote element removed
}
</script>

<!-- ============ Row highlighting (mobile & desktop) ============ -->
<script>
function installRowHighlighting() {
  const attach = (tbody) => {
    if (!tbody) return;
    tbody.addEventListener("pointerup", (e) => {
      const tr = e.target.closest("tr");
      if (!tr) return;
      const table = tr.closest("table");
      const was = tr.classList.contains("highlight-row");
      table.querySelectorAll("tbody tr").forEach(r => r.classList.remove("highlight-row"));
      if (!was) tr.classList.add("highlight-row");
    }, { passive: true });
  };
  attach(document.getElementById("forecastBody"));
  const observer = new MutationObserver(() => {
    document.querySelectorAll(".climoBody").forEach(attach);
  });
  observer.observe(document.getElementById("climatology"), { childList: true, subtree: true });
}
document.addEventListener("DOMContentLoaded", installRowHighlighting);
</script>
</html>