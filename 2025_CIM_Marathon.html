<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Peak Pace Weather California International Marathon -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, maximum-scale=10, viewport-fit=cover" />
  <title id="pageTitle">California International Marathon | Peak Pace</title>

  <!-- Fonts & Libraries -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
/* ===== Base + Responsive (pinch-zoom enabled) ===== */
html, body { overflow-x: hidden; touch-action: pan-x pan-y pinch-zoom; zoom: 1; }
body { margin: 0; padding: 0; font-family: "Source Sans Pro", Arial, sans-serif; color: #111; background: #fff; line-height: 1.5; }
:root { --ink:#111; --muted:#555; --line:#ddd; --pp-dark:#003546; --blaze:#37BC7D; --highlight:#FF6700; --hoverRow:#fff3e6; }

/* Allow pinch zoom and vertical scrolling on interactive elements */
#map { touch-action: pan-x pan-y pinch-zoom; }
canvas { touch-action: pan-x pan-y pinch-zoom; }
table { touch-action: pan-x pan-y pinch-zoom; }

/* ===== Layout + Header ===== */
.page-wrapper { width: 100%; max-width: 1000px; margin: 0 auto; padding: 0 16px; box-sizing: border-box; }
.main-header { text-align: center; font-family: "Montserrat", sans-serif; font-weight: 800; font-size: clamp(36px, 6vw, 52px); letter-spacing: .05em; text-transform: uppercase; color: #000; margin: 28px 0 18px; line-height: 1; }
header { text-align:center; margin:8px auto 14px; }
header h2 { margin:0; font-size:32px; font-weight:700; }
#countdown { font-size:20px; font-weight:600; margin-top:6px; color:#333; }

/* ===== Uniform panel widths ===== */
section, #elevSection, #map, #paceBox { width: 100%; max-width: 100%; margin: 18px auto 0; box-sizing: border-box; }
section, #elevSection { border:1px solid #ccc; border-radius:8px; background:#fff; padding:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
section:last-of-type { margin-bottom:24px; }
section h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }
#sources h3 { display:flex; align-items:center; justify-content:center; gap:8px; transition:color 0.2s; }
#sources h3:hover { color:#FF6700; }
#climoTitle:hover, #tableHeader:hover { color:#FF6700; }
#sourcesToggle, #climoToggle, #forecastToggle { font-size:14px; color:#666; transition:transform 0.2s; }
#sourcesContent, #climoContent, #forecastContent { transition:all 0.3s ease; }
#sourcesContent h4 { margin:12px 0 6px; }

/* Map */
#mapSection { width: 100%; max-width: 100%; margin: 18px auto 0; box-sizing: border-box; border:1px solid #ccc; border-radius:8px; background:#fff; padding:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); overflow:hidden; }
#mapSection h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }
#mapTitle { transition:color 0.2s; }
#mapTitle:hover, #elevTitle:hover { color:#FF6700; }
#mapToggle, #elevToggle { font-size:14px; color:#666; transition:transform 0.2s; }
#mapContent, #elevContent { transition:all 0.3s ease; box-sizing:border-box; }
#map { height: 600px; width: 100%; margin:0; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); box-sizing:border-box; }

/* Elevation */
#elevSection { width: 100%; max-width: 100%; margin: 18px auto; border: 1px solid #ccc; border-radius: 8px; background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.08); padding: 16px; box-sizing: border-box; }
#elevSection h3 { text-align:center; margin:0 0 12px; font-size:20px; font-weight:700; }
#elevWrap { position:relative; width:100%; height:225px; margin:0 auto; padding:0; box-sizing:border-box; }
#elevationChart { position:absolute; inset:0; width:100% !important; height:100% !important; display:block; box-sizing:border-box; cursor:pointer; }

/* ===== Pace & Wave Control Bar ===== */
#paceBox { text-align:center; padding:20px 24px; margin:18px auto; background:#fff; border:1px solid #ccc; border-radius:10px; box-shadow:0 2px 4px rgba(0,0,0,0.08); }
#paceBox h3 { margin:0 0 20px; font-size:22px; font-weight:700; }
#paceBox.loading { opacity: 0.6; pointer-events: none; }

.control-row { display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:16px; padding-bottom:16px; border-bottom:1px solid #eee; }
.control-row:last-of-type { margin-bottom:0; padding-bottom:0; border-bottom:none; }
#buttonRow { justify-content:flex-start; padding-left:20px; gap:16px; }
.control-row label { font-weight:700; color:#000; font-size:15px; white-space:nowrap; }
.control-row select, .control-row input { font-size:14px; border:1px solid #ccc; border-radius:6px; background:#fff; color:#111; padding:8px 12px; cursor:pointer; height:38px; }

/* Clean minimal select styling - no icon */
select {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 8px 12px;
  background: #fff;
  color: #111;
  font-size: 14px;
  cursor: pointer;
}

select::-ms-expand {
  display: none;
}
#customTimeInput { display:none; min-width: 150px; }
#startHour, #startMinute { min-width:65px; width:65px; }
#paceMin, #paceSec { min-width:65px; width:65px; }

.pace-input-group { display:flex; align-items:center; gap:6px; white-space:nowrap; }
.pace-input-group span { color:#000; font-size:15px; font-weight:700; }

#paceGo { font-size:14px; font-weight:600; border:1px solid #003546; border-radius:6px; color:#fff; background:#003546; cursor:pointer; padding:9px 20px; height:38px; min-width:200px; transition:background 0.2s ease; margin-left:4px; white-space: nowrap; position: relative; }
#paceGo:hover { background:#FF6700; }
#paceGo:disabled { background:#ccc; cursor:not-allowed; border-color:#ccc; }

#paceConfirm { font-size:14px; color:#888; margin-left:12px; font-style:italic; }
#paceConfirm.success { color:#FF6700; font-style:normal; font-weight:600; }

/* Forecast tabs */
#forecastTabs { display:flex; gap:6px; }
.forecastTab { padding:8px 14px; border:1px solid #ccc; border-radius:6px; background:#f9f9f9; color:#555; font-size:13px; font-weight:600; cursor:not-allowed; transition: background .2s ease, color .2s ease, border-color .2s ease; }
.forecastTab:hover:not(:disabled) { background: var(--pp-dark); color:#fff; border-color: var(--pp-dark); }
.forecastTab.active { background: var(--pp-dark); color:#fff; border-color: var(--pp-dark); cursor:pointer; }
.forecastTab:disabled { opacity: 0.5; cursor:not-allowed; }
.forecastTab:enabled { cursor:pointer; }
.forecastTab.loading { opacity: 0.6; cursor: wait; }

/* Forecast source toggle */
#forecastSourceToggle { display:flex; gap:6px; }
.sourceToggleBtn { padding:8px 14px; border:1px solid #ccc; border-radius:6px; background:#f9f9f9; color:#555; font-size:13px; font-weight:600; cursor:pointer; transition: background .2s ease, color .2s ease, border-color .2s ease; position: relative; }
.sourceToggleBtn:hover { background: var(--pp-dark); color:#fff; border-color: var(--pp-dark); }
.sourceToggleBtn.active { background: var(--pp-dark); color:#fff; border-color: var(--pp-dark); cursor:pointer; }
.sourceToggleBtn:disabled { opacity: 0.5; cursor: not-allowed; border-color: #ddd; pointer-events: auto; position: relative; }
.sourceToggleBtn:disabled:hover { background: #f5f5f5; }
.sourceToggleBtn:enabled { cursor:pointer; }
/* Custom tooltip for disabled buttons */
.sourceToggleBtn:disabled[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
}
.sourceToggleBtn:disabled[data-tooltip]:hover::after {
  opacity: 1;
}


/* Tables */
table { width:100%; border-collapse:collapse; }
th, td { border:1px solid #ccc; padding:8px; text-align:center; font-size:14px; }
th { background:#f0f0f0; font-weight:700; }
#climoAvgRow { font-weight:700; background:#f5f5f5; }

/* Climate table - equal column distribution */
#climatology table { table-layout: fixed; width: 100%; }
#climatology th, #climatology td { width: 20%; } /* 5 columns = 20% each */

/* Hover (desktop) */
#forecastBody tr:hover, .climoBody tr:hover { background: var(--hoverRow); }

/* Tap highlight (mobile & desktop) */
#forecastBody tr, .climoBody tr { cursor: pointer; -webkit-tap-highlight-color: transparent; }
.highlight-row { background: var(--hoverRow) !important; box-shadow: inset 0 0 0 2px var(--highlight); transition: background .2s ease, box-shadow .2s ease; }

.note { font-size:12px; text-align:center; margin-top:8px; color:var(--muted); }

/* Leaflet styles & tooltips */
.leaflet-marker-icon { cursor:pointer; transition: transform 150ms ease; }
.leaflet-marker-icon:hover { transform: scale(1.2); }
.leaflet-tooltip, .pp-tooltip { background:#fff; border:2px solid var(--highlight); border-radius:8px; color:var(--ink); font-size:13px; font-weight:500; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:6px 10px; }
.leaflet-control a { background-color:var(--pp-dark) !important; color:#fff !important; border:1px solid var(--pp-dark) !important; width:30px !important; height:30px !important; line-height:30px !important; text-align:center; font-size:16px; }
.leaflet-control a:hover { background-color: var(--blaze) !important; border-color: var(--blaze) !important; }

/* Blaze markers */
.blaze-dot { width:20px; height:20px; background:var(--blaze); border:2px solid #222; border-radius:50%; transition:transform .2s ease; transform-origin:center; }
.blaze-dot:hover { transform: scale(1.4); cursor:pointer; }
.blaze-dot.highlighted { transform: scale(1.6); background: var(--highlight); }

/* Prevent focus-snap on Leaflet */
.leaflet-container { scroll-margin-top:0; scroll-behavior:auto; }
.leaflet-container:focus { outline:none; scroll-margin-top:0; }

/* Loading spinner */
.spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid var(--pp-dark); border-radius: 50%; animation: spin 1s linear infinite; margin-left: 4px; vertical-align: middle; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

/* ===== MOBILE RESPONSIVENESS ===== */
@media (max-width: 768px) {
  /* Base font sizes - more readable on mobile */
  body { font-size: 16px; }
  
  /* Headers scale down */
  .main-header { font-size: clamp(28px, 5vw, 40px); margin: 20px 0 14px; }
  header h2 { font-size: 24px; }
  #countdown { font-size: 16px; }
  
  /* Section headers */
  section h3 { font-size: 18px; margin-bottom: 14px; }
  
  /* Labels and inputs */
  label { font-size: 15px; }
  
  /* Touch targets: minimum 44px height (Apple standard) */
  input[type="number"],
  input[type="text"],
  select,
  button,
  .sourceToggleBtn,
  .forecastTab {
    min-height: 44px;
    font-size: 16px;
    padding: 8px 12px;
  }
  
  /* Control rows: stack on mobile */
  .control-row {
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;
  }
  
  .control-row > div {
    width: 100%;
    flex-direction: column;
  }
  
  /* Input groups: stack vertically */
  .pace-input-group {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  /* Disable tooltips on mobile - rely on modal instead */
  .leaflet-tooltip {
    display: none !important;
  }
  
  .pp-tooltip {
    display: none !important;
  }
  
  /* Hide any tooltip elements that might appear */
  .leaflet-tooltip,
  .pp-tooltip,
  [role="tooltip"],
  .chartjs-tooltip,
  .leaflet-popup {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    width: 0 !important;
    height: 0 !important;
    position: fixed !important;
    top: -9999px !important;
    left: -9999px !important;
    z-index: -9999 !important;
  }
  
  /* Make inputs full width on mobile */
  input[type="number"],
  input[type="text"],
  select {
    flex: 1;
    min-width: auto;
  }
  
  #startHour,
  #startMinute {
    width: auto;
    flex: 0 0 auto;
    min-width: 60px;
  }
  
  #paceMin,
  #paceSec {
    width: auto;
    flex: 0 0 auto;
    min-width: 60px;
  }
  
  /* Pace box adjustments */
  #paceBox h3 { margin-bottom: 16px; }
  
  /* Map height: responsive but still usable */
  #map { height: 400px; }
  
  /* Elevation chart: responsive height */
  #elevWrap { height: 280px; }
  
  /* Table: better mobile spacing */
  table { font-size: 13px; }
  th, td { padding: 8px 6px; }
  
  /* Forecast notes: stack on very small screens */
  #forecastValidLabel,
  #forecastDateLabel,
  #forecastSourceMethodLabel {
    display: block;
    margin: 4px 0;
  }
}

/* Larger phones / small tablets */
@media (max-width: 600px) {
  .page-wrapper { padding: 0 12px; }
  
  /* Reduce margins on small screens */
  section, #elevSection { margin: 14px auto 0; padding: 12px; }
  
  /* Button row wrapping */
  #buttonRow { flex-wrap: wrap; }
  
  /* Forecast tabs: wrap if needed */
  #forecastTabs { flex-wrap: wrap; }
  
  /* Tone down shadow on small screens */
  section, #elevSection { box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
}

/* Landscape orientation */
@media (orientation: landscape) {
  /* Tighter spacing in landscape */
  .control-row { margin-bottom: 8px; padding-bottom: 8px; }
  
  #map { height: 350px; }
  #elevWrap { height: 200px; }
}


/* Pace Cutoff Modal */
#paceCutoffModal[style*="display:flex"] {
  display: flex !important;
}

</style>
</head>

<body>
  <div class="page-wrapper">
    <div class="main-header">PEAKPACEWEATHER.COM</div>

    <header>
      <h2 id="raceName">California International Marathon</h2>
      <div id="countdown">Loading countdown...</div>
    </header>

    <!-- Pace Cutoff Warning Modal -->
    <div id="paceCutoffModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
      <div style="background:#fff; border-radius:12px; padding:32px; max-width:500px; box-shadow:0 4px 20px rgba(0,0,0,0.3); text-align:center;">
        <h2 style="margin:0 0 16px; color:#FF6700; font-size:24px;">Race Director Cutoff</h2>
        <p style="margin:0 0 16px; color:#333; font-size:16px; line-height:1.6;">
          The official race finish cutoff is <strong>6 hours (13:44 min/mile)</strong>. 
        </p>
        <p style="margin:0 0 24px; color:#666; font-size:14px;">
          Your selected pace exceeds this limit. Would you like to continue anyway?
        </p>
        <div style="display:flex; gap:12px; justify-content:center; margin-bottom:16px;">
          <button id="paceContinueBtn" style="padding:10px 24px; background:#FF6700; color:#fff; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:14px;">Continue</button>
          <button id="paceAdjustBtn" style="padding:10px 24px; background:#003546; color:#fff; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:14px;">Adjust Pace</button>
        </div>
        <p style="margin:0; color:#555; font-size:12px;">
          <a href="https://runsra.org/california-international-marathon/general-information/" target="_blank" rel="noopener" style="color:#FF6700; text-decoration:none;">View Race FAQ</a>
        </p>
      </div>
    </div>

    <!-- Station Detail Modal -->
    <div id="stationModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:10000; align-items:center; justify-content:center; padding:12px; overflow-y:auto;">
      <div style="background:#fff; border-radius:10px; max-width:450px; width:100%; box-shadow:0 4px 30px rgba(0,0,0,0.3); max-height:85vh; overflow-y:auto; margin:auto;">
        
        <!-- Header with brand dark blue background -->
        <div style="background:#003546; padding:16px; border-radius:10px 10px 0 0; position:relative;">
          <button id="stationModalClose" style="position:absolute; top:8px; right:8px; background:none; border:none; font-size:24px; cursor:pointer; color:#fff; padding:0; width:28px; height:28px; display:flex; align-items:center; justify-content:center;">&times;</button>
          <h2 id="stationModalName" style="margin:0; color:#fff; font-size:22px; font-weight:700; padding-right:32px;"></h2>
        </div>
        
        <!-- Content area -->
        <div style="padding:16px;">
          
          <!-- Distance & Elevation (compact 2-column) -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:14px;">
            <div>
              <div style="color:#666; font-size:11px; font-weight:600; text-transform:uppercase; margin-bottom:3px; letter-spacing:0.5px;">Distance</div>
              <div id="stationModalDistance" style="color:#111; font-size:16px; font-weight:700;"></div>
            </div>
            <div>
              <div style="color:#666; font-size:11px; font-weight:600; text-transform:uppercase; margin-bottom:3px; letter-spacing:0.5px;">Elevation</div>
              <div id="stationModalElevation" style="color:#111; font-size:16px; font-weight:700;"></div>
            </div>
          </div>
          
          <!-- Elapsed & ETA (compact 2-column) -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:14px; padding-bottom:14px; border-bottom:2px solid #111;">
            <div>
              <div style="color:#666; font-size:11px; font-weight:600; text-transform:uppercase; margin-bottom:3px; letter-spacing:0.5px;">Elapsed Time</div>
              <div id="stationModalElapsed" style="color:#FF6700; font-size:16px; font-weight:700;"></div>
            </div>
            <div>
              <div style="color:#666; font-size:11px; font-weight:600; text-transform:uppercase; margin-bottom:3px; letter-spacing:0.5px;">Arrival Time</div>
              <div id="stationModalETA" style="color:#FF6700; font-size:16px; font-weight:700;"></div>
            </div>
          </div>
          
          <!-- Weather section with colored header -->
          <div style="margin-bottom:14px;">
            <div style="color:#003546; font-size:12px; font-weight:700; text-transform:uppercase; margin-bottom:10px; letter-spacing:0.5px;">Peak Pace Forecast</div>
            
            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; background:#f8f8f8; padding:12px; border-radius:6px;">
              <!-- Temperature -->
              <div style="text-align:center;">
                <div style="color:#666; font-size:10px; font-weight:600; text-transform:uppercase; margin-bottom:4px; letter-spacing:0.5px;">Temp</div>
                <div id="stationModalTemp" style="color:#FF6700; font-size:20px; font-weight:700;"></div>
              </div>
              
              <!-- Wind -->
              <div style="text-align:center;">
                <div style="color:#666; font-size:10px; font-weight:600; text-transform:uppercase; margin-bottom:4px; letter-spacing:0.5px;">Wind</div>
                <div id="stationModalWind" style="color:#111; font-size:13px; font-weight:600;"></div>
              </div>
              
              <!-- Conditions -->
              <div style="text-align:center;">
                <div style="color:#666; font-size:10px; font-weight:600; text-transform:uppercase; margin-bottom:4px; letter-spacing:0.5px;">Conditions</div>
                <div id="stationModalCond" style="color:#111; font-size:13px; font-weight:600;"></div>
              </div>
            </div>
          </div>
          
          <!-- Close button with brand orange -->
          <button id="stationModalCloseBtn" style="width:100%; padding:14px; background:#FF6700; color:#fff; border:none; border-radius:6px; font-weight:700; cursor:pointer; font-size:15px; transition:background 0.2s ease;">Close</button>
        </div>
        
      </div>
    </div>

    <!-- Pace Controls -->
    <div id="paceBox">
      <h3>Peak Pace Parameters</h3>
      
      <div class="control-row">
        <div style="display: flex; gap: 24px; align-items: center;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <label>Start Time:</label>
            <div class="pace-input-group">
              <select id="startHour">
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7" selected>7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
              </select>
              <span>:</span>
              <select id="startMinute">
              </select>
              <span>AM</span>
            </div>
          </div>
          
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="paceMin">Target Pace (min/mile):</label>
            <div class="pace-input-group">
              <select id="paceMin"></select>
              <span>:</span>
              <select id="paceSec"></select>
            </div>
          </div>
        </div>
      </div>
      
      <div class="control-row" style="flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
          <label style="font-weight: 700; color: #000; font-size: 15px; white-space: nowrap;">Forecast Splits:</label>
          <div id="forecastTabs" style="display: flex; gap: 6px;"></div>
        </div>
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
          <label style="font-weight: 700; color: #000; font-size: 15px; white-space: nowrap;">Forecast Sources:</label>
          <div id="forecastSourceToggle" style="display: flex; gap: 6px;"></div>
        </div>
      </div>
      
      <div class="control-row" id="buttonRow">
        <button id="paceGo">Generate Peak Pace Forecast</button>
        <span id="paceConfirm">Input forecast parameters</span>
      </div>
    </div>

    <!-- ============ Climatology ============ -->
    <section id="climatology">
      <h3 id="climoTitle" onclick="toggleClimatology()" style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:center; gap:8px;">
        Peak Pace Climatology (December 7) <span id="climoToggle">−</span>
      </h3>
      <div id="climoContent">
        <div id="climoTable"></div>
      </div>
    </section>

    <!-- Forecast Summary -->
    <section id="summary">
      <h3 id="tableHeader" onclick="toggleForecast()" style="margin-bottom:14px; cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:center; gap:8px;">
        Peak Pace Forecast <span id="forecastToggle">−</span>
      </h3>
      <div id="forecastContent">
        <table>
          <thead>
            <tr><th>Station</th><th>Distance (mi)</th><th>Elapsed</th><th>ETA</th><th>Temp (°F)</th><th>Wind</th><th>Conditions</th></tr>
          </thead>
          <tbody id="forecastBody">
            <tr id="forecastPlaceholder">
              <td colspan="7" style="text-align:center; padding:40px 20px; color:#888; font-style:italic;">
                Input forecast parameters above and click "Generate Peak Pace Forecast"
              </td>
            </tr>
          </tbody>
        </table>
        <div style="text-align:center; font-size:12px; color:#555; margin-top:12px;">
          <span id="forecastValidLabel"></span><span id="forecastNotesSeparator1" style="margin: 0 8px; color:#999;"> | </span><span id="forecastDateLabel" style="color:#666;"></span><span id="forecastNotesSeparator2" style="margin: 0 8px; color:#999;"> | </span><span id="forecastSourceMethodLabel" style="color:#666;"></span>
        </div>
      </div>
    </section>

    <!-- Map -->
    <section id="mapSection">
      <h3 id="mapTitle" onclick="toggleMap()" style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:center; gap:8px;">
        Interactive Course Map <span id="mapToggle">+</span>
      </h3>
      <div id="mapContent" style="display: none;">
        <div id="map"></div>
      </div>
    </section>

    <!-- Elevation -->
    <section id="elevSection">
      <h3 id="elevTitle" onclick="toggleElevation()" style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:center; gap:8px;">
        Interactive Elevation Profile <span id="elevToggle">+</span>
      </h3>
      <div id="elevContent" style="display: none;">
        <div id="elevWrap"><canvas id="elevationChart"></canvas></div>
      </div>
    </section>

    <!-- Sources -->
    <section id="sources">
      <h3 onclick="toggleDataSources()" style="cursor:pointer; user-select:none;">
        Data Sources <span id="sourcesToggle">−</span>
      </h3>
      <div id="sourcesContent">
        <div style="margin-bottom:16px;">
          <h4 style="font-size:15px; font-weight:700; margin:8px 0 6px; color:#003546;">Weather Forecasts</h4>
          <ul style="font-size:13px; color:#555; line-height:1.6; margin:0;">
            <li><strong>NOAA/NWS forecastHourly:</strong> Primary forecast source for near-term predictions (0-6.5 days). Provides hourly temperature, wind speed/direction, and detailed weather conditions. Updated multiple times daily. Accessed via <a href="https://www.weather.gov/documentation/services-web-api" target="_blank" rel="noopener">Weather.gov API</a>.</li>
            <li><strong>Open-Meteo:</strong> Extended range forecast source (0-16 days). Uses ensemble models combining GFS, ECMWF, and other global weather models. Provides hourly forecasts with WMO weather codes. Accessed via <a href="https://open-meteo.com/en/docs" target="_blank" rel="noopener">Open-Meteo API</a>.</li>
            <li><strong>Tiered System:</strong> When race is within 6.5 days, both NOAA and Open-Meteo forecasts are available for comparison. Beyond 6.5 days, only Open-Meteo is available. NOAA is generally preferred for short-term accuracy.</li>
          </ul>
        </div>
        
        <div style="margin-bottom:16px;">
          <h4 style="font-size:15px; font-weight:700; margin:8px 0 6px; color:#003546;">Historical Climatology</h4>
          <ul style="font-size:13px; color:#555; line-height:1.6; margin:0;">
            <li><strong>Start Location (Folsom):</strong> 10 years of observations (2015-2024) from Mather Airport (MHR), ICAO identifier KMHR, located approximately 5 miles from the start line. Data shows conditions at 7:00 AM PST on December 7.</li>
            <li><strong>Finish Location (Sacramento):</strong> 10 years of observations (2015-2024) from Sacramento International Airport (SAC), showing both start time and variable finish time conditions based on your target pace. Demonstrates typical temperature rise and wind pattern changes throughout the race.</li>
            <li><strong>Data Source:</strong> All climatology data from <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">Iowa State University IEM ASOS Archive</a>, which provides quality-controlled ASOS/AWOS observations from automated airport weather stations.</li>
          </ul>
        </div>
        
        <div style="margin-bottom:16px;">
          <h4 style="font-size:15px; font-weight:700; margin:8px 0 6px; color:#003546;">Route & Elevation Data</h4>
          <ul style="font-size:13px; color:#555; line-height:1.6; margin:0;">
            <li><strong>Course Route:</strong> Officially published GPS coordinates from race organizers showing the certified 26.2-mile point-to-point course from Folsom to Sacramento.</li>
            <li><strong>Elevation Profile:</strong> Extracted from Mapbox Terrain-RGB tileset at zoom level 13, providing approximately 10-meter resolution. Shows the net ~200ft descent from Folsom (elevation ~230ft) to Sacramento (elevation ~30ft).</li>
            <li><strong>Station Locations:</strong> Mile markers, 5K splits, and official aid station coordinates along the race route. Each station is geocoded for precise weather forecast retrieval.</li>
          </ul>
        </div>
        
        <div style="margin-bottom:8px;">
          <h4 style="font-size:15px; font-weight:700; margin:8px 0 6px; color:#003546;">Mapping & Visualization</h4>
          <ul style="font-size:13px; color:#555; line-height:1.6; margin:0;">
            <li><strong>Base Maps:</strong> OpenStreetMap tiles for street-level detail</li>
            <li><strong>Interactive Features:</strong> Leaflet.js for map rendering and marker interactions</li>
            <li><strong>Elevation Charts:</strong> Chart.js for responsive elevation profile visualization</li>
          </ul>
        </div>
        
        <div class="note" style="margin-top:12px; padding-top:12px; border-top:1px solid #ddd;">
          <strong>Note on Data Accuracy:</strong> Weather forecasts are inherently uncertain and become less accurate with increasing lead time. Historical climatology provides context but does not guarantee similar conditions for race day. Elevation data is accurate to Â±10 meters. Use this tool as planning guidance, not as definitive race day predictions.
        </div>
      </div>
    </section>
  </div>
</body>

<!-- ============ CONFIG ============ -->
<script>
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGlsbG9uZHVyaW5pY2siLCJhIjoiY21memtlbm83MDNycTJtb3JtdGxucWpkMiJ9.W7Ge6XYCd0Gfl9f7YQ2dNw";

const raceConfig = {
  name: "California International Marathon",
  date: new Date("2025-12-07T07:00:00-08:00"), // Pacific Time (PST)
  city: "Folsom to Sacramento, CA",
  climoBaseUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/",
  routeUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_CIM_Route.json",
  stationUrls: {
    option1: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_CIM_Stations_Option1.json",
    option2: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_CIM_Stations_Option2.json",
    option3: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/2025_CIM_Stations_Option3.json"
  },
  startClimateUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/CIM_Folsom_Start_Climate.json",
  finishClimateUrl: "https://raw.githubusercontent.com/PeakPaceWeather/peakpaceweather/refs/heads/main/CIM_December_7_Comprehensive_Climate.json",
  elevationZoom: 13,
  route: null,
  allStations: {} // Will hold all 3 station options
};

// Log initial configuration for debugging
console.log(`=== RACE CONFIG INITIALIZED ===`);
try {
  if (!raceConfig.date || isNaN(raceConfig.date.getTime())) {
    throw new Error('Race date is invalid');
  }
  console.log(`Race date (UTC): ${raceConfig.date.toISOString()}`);
  console.log(`Race date (Pacific): ${raceConfig.date.toLocaleString('en-US', { timeZone: 'America/Los_Angeles', dateStyle: 'full', timeStyle: 'long' })}`);
} catch (e) {
  console.error(`❌ ERROR: ${e.message}`);
  console.error(`Race date value: ${raceConfig.date}`);
  console.error(`Please check the date format in raceConfig. Use format: new Date("YYYY-MM-DDTHH:MM:SS-08:00")`);
}
console.log(`Computer local time: ${new Date().toLocaleString()}`);
console.log(`Computer timezone offset: UTC${new Date().getTimezoneOffset() > 0 ? '-' : '+'}${Math.abs(new Date().getTimezoneOffset() / 60)}`);

// Current active option
let currentStationOption = 'option1';
let currentForecastSource = 'noaa'; // 'noaa' or 'openmeteo'
let bothSourcesAvailable = false;
let loadedOptions = new Set(); // Track which station options have been loaded
let noaaHasValidData = false;    // Track if NOAA has any valid forecast data
let openMeteoHasValidData = false; // Track if Open-Meteo has any valid forecast data
let noaaAvailableTime = null; // Track when NOAA forecast becomes available
</script>

<!-- ============ COUNTDOWN ============ -->
<script>
function updateCountdown() {
  const diff = raceConfig.date - new Date();
  const el = document.getElementById("countdown");
  const raceDateStr = raceConfig.date.toLocaleString([], { month:"long", day:"numeric", year:"numeric" });
  
  if (diff <= 0) { 
    el.textContent = `${raceDateStr} – Race Day!`; 
    return; 
  }
  
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  
  let countdownText = "";
  if (days > 1) {
    countdownText = `${days} days`;
  } else if (days === 1) {
    countdownText = "Tomorrow";
  } else {
    countdownText = `${hours} ${hours === 1 ? 'hour' : 'hours'}`;
  }
  
  el.textContent = `${raceDateStr} (${countdownText})`;
}
setInterval(updateCountdown, 60000);
updateCountdown();
</script>

<!-- ============ PACE & UI CONTROLS ============ -->
<script>
function paceMinPerMiFromUI(){
  const m = Number(document.getElementById('paceMin').value) || 0;
  const s = Number(document.getElementById('paceSec').value) || 0;
  return m + s/60;
}
function formatElapsedFromMinutes(mins){
  const totalSeconds = Math.round(mins * 60);
  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// Pace cutoff validation
let userConfirmedSlowPace = false;
const MAX_PACE_MIN = 13;
const MAX_PACE_SEC = 44;
const MAX_PACE_TOTAL = MAX_PACE_MIN + MAX_PACE_SEC / 60; // 13.7333 min/mi

function checkPaceCutoff() {
  const currentPace = paceMinPerMiFromUI();
  
  if (currentPace > MAX_PACE_TOTAL) {
    // Show the warning modal
    document.getElementById('paceCutoffModal').style.display = 'flex';
    return false; // Don't proceed with forecast
  }
  
  // Reset the flag when user generates a valid forecast
  userConfirmedSlowPace = false;
  return true; // Proceed with forecast
}



// Format time in Pacific timezone with PST/PDT indication
function formatPacificTime(date, includeTimezone = false) {
  const options = { 
    hour: "numeric", 
    minute: "2-digit",
    timeZone: "America/Los_Angeles"
  };
  const timeStr = date.toLocaleTimeString([], options);
  
  if (!includeTimezone) return timeStr;
  
  // Determine if PST or PDT based on date
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();
  
  // PST: Nov first Sunday to March second Sunday
  // PDT: March second Sunday to Nov first Sunday
  // December 7 is always in PST
  const isDST = month > 2 && month < 10; // Rough approximation
  const tz = isDST ? "PDT" : "PST";
  
  return `${timeStr} ${tz}`;
}

// Initialize pace dropdowns and start time minutes
document.addEventListener('DOMContentLoaded', function() {
  // Initialize pace dropdowns
  const mins=document.getElementById('paceMin'), secs=document.getElementById('paceSec');
  for(let m=4;m<=13;m++){ let o=document.createElement('option'); o.value=m; o.textContent=m; mins.appendChild(o); }
  for(let s=0;s<60;s++){ let o=document.createElement('option'); o.value=s; o.textContent=String(s).padStart(2,'0'); secs.appendChild(o); }
  mins.value=9; secs.value=0;
  
  // Initialize start time minute dropdown (every minute 00-59)
  const startMin = document.getElementById('startMinute');
  for(let m=0;m<60;m++){
    let o = document.createElement('option');
    o.value = String(m).padStart(2,'0');
    o.textContent = String(m).padStart(2,'0');
    if(m === 0) o.selected = true;  // Default to :00
    startMin.appendChild(o);
  }
  
  checkAllStepsComplete();
  
  // Initialize forecast controls (disabled until forecast is generated)
  initializeForecastControls();
  
  // Pace cutoff modal button handlers
  document.getElementById('paceContinueBtn').addEventListener('click', function() {
    userConfirmedSlowPace = true;
    document.getElementById('paceCutoffModal').style.display = 'none';
    // Trigger the forecast generation
    document.getElementById('paceGo').click();
  });

  document.getElementById('paceAdjustBtn').addEventListener('click', function() {
    document.getElementById('paceCutoffModal').style.display = 'none';
    // Focus on pace dropdown to help user adjust
    document.getElementById('paceMin').focus();
  });
});

// Start time handling - CRITICAL: Must use Pacific time, not local computer time
function updateStartTime() {
  const hh = parseInt(document.getElementById('startHour').value);
  const mm = parseInt(document.getElementById('startMinute').value);
  
  try {
    // Get the race date from config (already set correctly in raceConfig)
    const raceDate = raceConfig.date;
    
    if (!raceDate || isNaN(raceDate.getTime())) {
      throw new Error('Race date is invalid in config');
    }
    
    const year = raceDate.getFullYear();
    const month = String(raceDate.getMonth() + 1).padStart(2, '0');
    const day = String(raceDate.getDate()).padStart(2, '0');
    
    // Create date explicitly in Pacific time (PST = UTC-8)
    const dateStr = `${year}-${month}-${day}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00-08:00`;
    const newDate = new Date(dateStr);
    
    if (isNaN(newDate.getTime())) {
      throw new Error(`Failed to create date from: ${dateStr}`);
    }
    
    raceConfig.date = newDate;
    console.log(`Start time set to: ${raceConfig.date.toISOString()} (${formatPacificTime(raceConfig.date, true)})`);
  } catch (e) {
    console.error(`❌ updateStartTime error: ${e.message}`);
    console.error(`Check that raceConfig.date is a valid Date object`);
  }
  
  checkAllStepsComplete();
}

document.getElementById('startHour').addEventListener('change', updateStartTime);
document.getElementById('startMinute').addEventListener('change', updateStartTime);

// Pace selection
document.getElementById('paceMin').addEventListener('change', checkAllStepsComplete);
document.getElementById('paceSec').addEventListener('change', checkAllStepsComplete);

function checkAllStepsComplete() {
  const step1 = document.getElementById('startHour').value !== '' && document.getElementById('startMinute').value !== '';
  const step2 = document.getElementById('paceMin').value !== '';
  
  const goBtn = document.getElementById('paceGo');
  const confirmEl = document.getElementById('paceConfirm');
  
  if (step1 && step2) {
    goBtn.disabled = false;
    confirmEl.textContent = 'Ready to generate forecast';
    confirmEl.classList.remove('success');
  } else {
    goBtn.disabled = true;
    confirmEl.textContent = 'Input forecast parameters';
    confirmEl.classList.remove('success');
  }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  // Set race date based on default dropdown selections
  updateStartTime();
  checkAllStepsComplete();
});

// Generate forecast - loads ALL station options
document.getElementById('paceGo').addEventListener('click', async function() {
  const paceBox = document.getElementById('paceBox');
  const goBtn = this;
  const confirmEl = document.getElementById('paceConfirm');
  
  // Check pace cutoff (only if user hasn't already confirmed)
  if (!userConfirmedSlowPace && !checkPaceCutoff()) {
    return; // Modal is showing, don't proceed
  }
  
  // Disable controls
  paceBox.classList.add('loading');
  goBtn.disabled = true;
  
  // Store button width before changing text to prevent shifting
  const buttonWidth = goBtn.offsetWidth;
  goBtn.style.width = buttonWidth + 'px';
  
  // Show loading
  const originalText = goBtn.textContent;
  goBtn.innerHTML = 'Generating Forecast<span class="spinner"></span>';
  
  let forecastSuccessful = false;
  
  try {
    // Source toggle is now always visible (buttons disabled until forecast generated)
    
    // Load all 3 station JSON files (fast)
    const [stations1, stations2, stations3] = await Promise.all([
      fetch(raceConfig.stationUrls.option1).then(r => r.json()),
      fetch(raceConfig.stationUrls.option2).then(r => r.json()),
      fetch(raceConfig.stationUrls.option3).then(r => r.json())
    ]);
    
    raceConfig.allStations = {
      option1: stations1,
      option2: stations2,
      option3: stations3
    };
    
    // Calculate bothSourcesAvailable FIRST before deciding what to fetch
    const pace = paceMinPerMiFromUI();
    const now = new Date();
    const noaaHorizonHours = 6.5 * 24;
    let minHrs = Infinity;
    const stations = raceConfig.allStations.option1;
    
    console.log(`\n=== FORECAST SOURCE AVAILABILITY CHECK ===`);
    console.log(`Current time: ${now.toISOString()} (${now.toLocaleString()})`);
    console.log(`Race start: ${raceConfig.date.toISOString()} (${raceConfig.date.toLocaleString('en-US', { timeZone: 'America/Los_Angeles', timeZoneName: 'short' })})`);
    console.log(`NOAA horizon: ${noaaHorizonHours} hours (6.5 days)`);
    console.log(`Target pace: ${pace.toFixed(2)} min/mile`);
    
    // Check first few stations
    for (let i = 0; i < Math.min(3, stations.length); i++) {
      const s = stations[i];
      const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
      const hrs = (eta - now) / 3_600_000;
      console.log(`  ${s.name} (${s.miles} mi): ETA ${eta.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' })} = ${hrs.toFixed(1)} hours away`);
      if (hrs < minHrs) minHrs = hrs;
    }
    
    bothSourcesAvailable = (minHrs <= noaaHorizonHours);
    
    // Calculate when NOAA forecast becomes available
    if (!bothSourcesAvailable && minHrs > noaaHorizonHours) {
      const hoursUntilNOAA = minHrs - noaaHorizonHours;
      noaaAvailableTime = new Date(now.getTime() + hoursUntilNOAA * 3_600_000);
    } else {
      noaaAvailableTime = null; // NOAA is already available
    }
    
    console.log(`\nMinimum hours to any station: ${minHrs.toFixed(1)}`);
    console.log(`NOAA available: ${minHrs <= noaaHorizonHours}`);
    console.log(`Both sources available: ${bothSourcesAvailable}`);
    if (noaaAvailableTime) {
      console.log(`NOAA will be available: ${noaaAvailableTime.toLocaleString('en-US', { timeZone: 'America/Los_Angeles', timeZoneName: 'short' })}\n`);
    } else {
      console.log();
    }
    
    // Clear loaded options
    loadedOptions.clear();
    
    // Generate forecasts ONLY for option1 with NOAA only (if available) - super fast initial load
    await updateForecastsForOption('option1', bothSourcesAvailable ? 'noaa' : 'openmeteo', (completed, total) => {
      // Progressive display - update table as each station completes
      displayForecastTable('option1');
    });
    loadedOptions.add('option1');
    
    // Show tabs (with loading states for option2 and option3)
    buildForecastTabs();
    
    // Display first option
    switchToStationOption('option1');
    
    // Success message
    const paceM = String(document.getElementById('paceMin').value).padStart(2,"0");
    const paceS = String(document.getElementById('paceSec').value).padStart(2,"0");
    const startTimeStr = formatPacificTime(raceConfig.date);
    const finishTime = new Date(raceConfig.date.getTime() + 26.2 * pace * 60000);
    const finishTimeStr = formatPacificTime(finishTime);
    
    confirmEl.textContent = `Start Time: ${startTimeStr} | Target Pace: ${paceM}:${paceS} min/mi | Finish Time: ${finishTimeStr}`;
    confirmEl.classList.add('success');
    
    // Update finish climate display
    updateFinishClimate(pace);
    
    // Background load option2 and option3
    loadRemainingOptionsInBackground();
    
    forecastSuccessful = true;
    
  } catch(e) {
    console.error('Forecast error:', e);
    confirmEl.textContent = 'Error generating forecast. Please try again.';
    confirmEl.style.color = '#d00';
  } finally {
    // Show appropriate button text based on success
    if (forecastSuccessful) {
      goBtn.innerHTML = '↓ View Forecast Below ↓';
    } else {
      goBtn.innerHTML = originalText;
    }
    goBtn.style.width = 'auto';  // Reset width constraint
    goBtn.disabled = false;
    paceBox.classList.remove('loading');
  }
});

async function loadRemainingOptionsInBackground() {
  // If both sources available, load Open-Meteo for option1 first (for toggle)
  if (bothSourcesAvailable) {
    console.log('Loading Open-Meteo for comparison...');
    try {
      await updateForecastsForOption('option1', 'openmeteo');
      console.log('Open-Meteo loaded! Building source toggle...');
      // Enable source toggle - buttons already exist from initialization
      buildSourceToggle();
      console.log('Source toggle enabled!');
    } catch(e) {
      console.error('Error loading Open-Meteo for option1:', e);
    }
  }
  
  // Load option2 (5K Splits) - use appropriate source based on availability
  try {
    const option2Source = bothSourcesAvailable ? 'both' : 'openmeteo';
    await updateForecastsForOption('option2', option2Source);
    loadedOptions.add('option2');
    updateTabLoadingState('option2');
  } catch(e) {
    console.error('Error loading option2:', e);
  }
  
  // Load option3 (Aid Stations) - use appropriate source based on availability
  try {
    const option3Source = bothSourcesAvailable ? 'both' : 'openmeteo';
    await updateForecastsForOption('option3', option3Source);
    loadedOptions.add('option3');
    updateTabLoadingState('option3');
  } catch(e) {
    console.error('Error loading option3:', e);
  }
}

function updateTabLoadingState(option) {
  const tab = document.querySelector(`[data-option="${option}"]`);
  if (tab && tab.classList.contains('loading')) {
    tab.classList.remove('loading');
    tab.textContent = getOptionLabel(option);
    
    // If user is currently viewing this option (waiting for it), refresh the display
    if (tab.classList.contains('active')) {
      switchToStationOption(option);
    }
  }
}

function getOptionLabel(option) {
  const labels = {
    option1: 'Mile Splits',
    option2: '5K Splits',
    option3: 'Aid Stations'
  };
  return labels[option] || option;
}

function getOptionName(option) {
  const names = {
    option1: 'Mile Splits',
    option2: '5K Splits',
    option3: 'Aid Stations'
  };
  return names[option] || option;
}

// Initialize forecast controls (disabled until forecast is generated)
function initializeForecastControls() {
  const tabsContainer = document.getElementById('forecastTabs');
  const sourceContainer = document.getElementById('forecastSourceToggle');
  
  if (!tabsContainer || !sourceContainer) {
    console.warn('Forecast control containers not found');
    return;
  }
  
  const options = [
    { key: 'option1', label: 'Mile Splits' },
    { key: 'option2', label: '5K Splits' },
    { key: 'option3', label: 'Aid Stations' }
  ];
  
  options.forEach(opt => {
    const tab = document.createElement('button');
    tab.className = 'forecastTab';
    tab.dataset.option = opt.key;
    tab.textContent = opt.label;
    tab.disabled = true;
    tab.addEventListener('click', () => switchToStationOption(opt.key));
    tabsContainer.appendChild(tab);
  });
  
  const sources = [
    { key: 'noaa', label: 'NOAA' },
    { key: 'openmeteo', label: 'Open-Meteo' }
  ];
  
  sources.forEach(src => {
    const btn = document.createElement('button');
    btn.className = 'sourceToggleBtn';
    btn.textContent = src.label;
    btn.dataset.source = src.key;
    btn.disabled = true;
    btn.addEventListener('click', () => switchForecastSource(src.key));
    
    // Add attributes for NOAA availability info
    if (src.key === 'noaa') {
      btn.id = 'nooaSourceBtn';
      btn.title = 'NOAA forecast becomes available 156 hours (6.5 days) before race start';
      btn.setAttribute('aria-label', 'NOAA forecast (available 6.5 days before race)');
    }
    
    sourceContainer.appendChild(btn);
  });
}

function buildForecastTabs() {
  const tabsContainer = document.getElementById('forecastTabs');
  if (!tabsContainer) return;
  
  // Enable all tabs
  tabsContainer.querySelectorAll('.forecastTab').forEach(tab => {
    tab.disabled = false;
    tab.classList.remove('loading');
  });
  
  // Activate first tab
  const firstTab = tabsContainer.querySelector('.forecastTab');
  if (firstTab) {
    firstTab.classList.add('active');
  }
}

function buildSourceToggle() {
  const toggleContainer = document.getElementById('forecastSourceToggle');
  if (!toggleContainer) return;
  
  const buttons = toggleContainer.querySelectorAll('.sourceToggleBtn');
  buttons.forEach(btn => {
    // Reset styles
    btn.style.opacity = '1';
    btn.style.cursor = 'pointer';
    btn.title = '';
    btn.removeAttribute('data-tooltip');
    
    // Handle based on which source actually has valid data
    if (btn.dataset.source === 'noaa') {
      if (!noaaHasValidData) {
        // NOAA has no valid data - disable
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
        
        if (noaaAvailableTime) {
          const availableStr = noaaAvailableTime.toLocaleString('en-US', { 
            timeZone: 'America/Los_Angeles', 
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            timeZoneName: 'short'
          });
          btn.setAttribute('data-tooltip', `Available: ${availableStr}`);
          btn.title = `Available: ${availableStr}`;
        } else {
          btn.setAttribute('data-tooltip', 'NOAA not available for this date');
          btn.title = 'NOAA not available for this date';
        }
      } else {
        // NOAA has valid data - enable
        btn.disabled = false;
        btn.title = '';
      }
    } else if (btn.dataset.source === 'openmeteo') {
      if (!openMeteoHasValidData) {
        // Open-Meteo has no valid data - disable
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
        btn.setAttribute('data-tooltip', 'Forecast data not available');
        btn.title = 'Forecast data not available';
      } else {
        // Open-Meteo has valid data - enable
        btn.disabled = false;
        btn.title = '';
      }
    }
  });
  
  // Make sure current source is still valid
  if (currentForecastSource === 'noaa' && !noaaHasValidData) {
    currentForecastSource = 'openmeteo';
  } else if (currentForecastSource === 'openmeteo' && !openMeteoHasValidData) {
    currentForecastSource = 'noaa';
  }
  
  // Activate current source button
  buttons.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.source === currentForecastSource);
  });
}

// Show message when user tries to click unavailable NOAA button
function showNOAAUnavailableMessage(availableTime) {
  let message = 'NOAA forecast is not yet available for this race date.\\n\\n';
  
  if (availableTime) {
    message += `NOAA forecasts become available 6.5 days before race start.\\n\\nThis NOAA forecast will be available: ${availableTime}\\n\\n`;
  } else {
    message += 'The race date is too far in the future for NOAA forecasts.\\n\\n';
  }
  
  message += 'Currently using Open-Meteo long-range forecast (available up to 16 days).';
  
  alert(message);
}

function switchForecastSource(source) {
  currentForecastSource = source;
  
  // Update active toggle button
  document.querySelectorAll('.sourceToggleBtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.source === source);
  });
  
  // Update all station data to use the selected source
  for (const opt in raceConfig.allStations) {
    const stations = raceConfig.allStations[opt];
    stations.forEach(s => {
      let displayForecast;
      if (source === 'noaa' && s.noaaForecast && s.noaaForecast.temp !== '-') {
        displayForecast = s.noaaForecast;
      } else if (source === 'openmeteo' && s.openMeteoForecast && s.openMeteoForecast.temp !== '-') {
        displayForecast = s.openMeteoForecast;
      } else if (s.openMeteoForecast && s.openMeteoForecast.temp !== '-') {
        displayForecast = s.openMeteoForecast;
      } else if (s.noaaForecast && s.noaaForecast.temp !== '-') {
        displayForecast = s.noaaForecast;
      } else {
        displayForecast = { temp: "-", wind: "-", cond: "Data unavailable" };
      }
      
      s.temp = displayForecast.temp;
      s.wind = displayForecast.wind;
      s.cond = displayForecast.cond;
      s.forecasts = [{ 
        eta: new Date(raceConfig.date.getTime() + s.miles * paceMinPerMiFromUI() * 60000),
        temp: displayForecast.temp, 
        wind: displayForecast.wind, 
        cond: displayForecast.cond, 
        elapsed: s.elapsed 
      }];
    });
  }
  
  // Refresh the current display
  displayForecastTable(currentStationOption);
  
  // Update map tooltips
  if(groupList && groupList.length && window.innerWidth > 768){
    groupList.forEach(g=>{
      if(g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.allStations[currentStationOption]));
    });
  }
  
  // Update source method label
  const sourceMethodLabel = document.getElementById("forecastSourceMethodLabel");
  if (sourceMethodLabel) {
    sourceMethodLabel.textContent = `Current: ${source === 'noaa' ? 'NOAA forecastHourly (6.5 day range)' : 'Open-Meteo API (16 day range)'}`;
  }
}

function switchToStationOption(option) {
  // Check if option is loaded
  if (!loadedOptions.has(option)) {
    // Show loading message in table
    const tbody = document.getElementById('forecastBody');
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:40px 20px; color:#888; font-style:italic;">Loading forecast data for this option... ÃƒÂ¢Ã‚ÂÃ‚Â³</td></tr>';
    
    // Update active tab
    document.querySelectorAll('.forecastTab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.option === option);
    });
    
    return; // Exit, wait for background load to complete
  }
  
  currentStationOption = option;
  
  // Update active tab
  document.querySelectorAll('.forecastTab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.option === option);
  });
  
  // Update table
  displayForecastTable(option);
  
  // Update map markers
  redrawMarkers(option);
  
  // Update elevation chart
  if (raceConfig.route && profileDistances.length) {
    buildElevationChart(profileDistances, profileElevations, raceConfig.allStations[option]);
  }
  
  // Update confirmation message
  const confirmEl = document.getElementById('paceConfirm');
  if (confirmEl.classList.contains('success')) {
    const paceM = String(document.getElementById('paceMin').value).padStart(2,"0");
    const paceS = String(document.getElementById('paceSec').value).padStart(2,"0");
    const startTimeStr = formatPacificTime(raceConfig.date);
    const pace = paceMinPerMiFromUI();
    const finishTime = new Date(raceConfig.date.getTime() + 26.2 * pace * 60000);
    const finishTimeStr = formatPacificTime(finishTime);
    confirmEl.textContent = `Start Time: ${startTimeStr} | Target Pace: ${paceM}:${paceS} min/mi | Finish Time: ${finishTimeStr}`;
  }
}

function displayForecastTable(option) {
  const tbody = document.getElementById('forecastBody');
  tbody.innerHTML = '';
  
  const stations = raceConfig.allStations[option];
  if (!stations) return;
  
  stations.forEach(s => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${s.name}</td>
      <td>${s.miles.toFixed(1)} mi</td>
      <td>${s.elapsed || '""'}</td>
      <td>${s.etaStr || '""'}</td>
      <td>${s.temp || '""'}</td>
      <td>${s.wind || '""'}</td>
      <td>${s.cond || '""'}</td>`;
    tbody.appendChild(row);
  });
}
</script>

<!-- ============ CLIMATOLOGY (dual system) ============ -->
<script>
let startClimateData = null;
let finishClimateData = null;

async function loadClimatology() {
  try {
    // Load both climate datasets
    const [startData, finishData] = await Promise.all([
      fetch(raceConfig.startClimateUrl).then(r => r.json()),
      fetch(raceConfig.finishClimateUrl).then(r => r.json())
    ]);
    
    startClimateData = startData;
    finishClimateData = finishData;
    
    // Build the climatology table and display initial data
    buildClimatologyTabs();
    
  } catch(err) {
    console.error('Climatology load failed:', err);
    document.getElementById('climoTitle').textContent = 'Climatology data unavailable';
  }
}

function buildClimatologyTabs() {
  const container = document.getElementById('climoTable');
  container.innerHTML = '';
  
  // Create single unified table
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Year</th>
        <th>Start Temp (°F)<br><span style="font-weight:400; font-size:12px;">Folsom, 7:00 AM</span></th>
        <th>Start Conditions<br><span style="font-weight:400; font-size:12px;">Folsom, 7:00 AM</span></th>
        <th>Finish Temp (°F)<br><span style="font-weight:400; font-size:12px;">Sacramento</span></th>
        <th>Finish Conditions<br><span style="font-weight:400; font-size:12px;">Sacramento</span></th>
      </tr>
    </thead>
    <tbody id="climateBody" class="climoBody"></tbody>
  `;
  
  container.appendChild(table);
  
  // Add note below table
  const note = document.createElement('div');
  note.className = 'note';
  note.innerHTML = `
    The California International Marathon is a point-to-point course from Folsom (elevation ~230 ft) to downtown Sacramento (elevation ~30 ft). 
    <strong>Start conditions</strong> are fixed at 7:00 AM PST on December 7 (2015-2024), recorded at Mather Airport (MHR), approximately 5 miles from the start line. 
    <strong>Finish conditions</strong> update dynamically based on your target pace and show historical weather at your estimated finish time, recorded at Sacramento International Airport (SAC). 
    Temperature typically rises throughout the race as the sun climbs and runners move into urban Sacramento. 
    Data source: <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">Iowa State IEM ASOS Archive</a>.
  `;
  container.appendChild(note);
  
  // Display initial start-only data
  displayStartOnlyClimate();
}

function displayStartOnlyClimate() {
  if (!startClimateData) return;
  
  const tbody = document.getElementById('climateBody');
  tbody.innerHTML = '';
  
  startClimateData.forEach(row => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.year}</td>
      <td>${row.temp}°F</td>
      <td>${row.conditions}</td>
      <td colspan="2" style="text-align:center; font-style:italic; color:#888;">Generate forecast to see finish data</td>`;
    tbody.appendChild(tr);
  });
}

function updateFinishClimate(pace) {
  if (!finishClimateData || !startClimateData) return;
  
  // Calculate finish time
  const finishMinutes = 26.2 * pace;
  const finishTime = new Date(raceConfig.date.getTime() + finishMinutes * 60000);
  
  console.log(`=== FINISH CLIMATE DEBUG ===`);
  console.log(`Race start: ${raceConfig.date.toISOString()} = ${formatPacificTime(raceConfig.date, true)}`);
  console.log(`Pace: ${pace.toFixed(2)} min/mile`);
  console.log(`Finish time: ${finishTime.toISOString()} = ${formatPacificTime(finishTime, true)}`);
  
  // Calculate ELAPSED TIME (not time of day!)
  const elapsedHours = Math.floor(finishMinutes / 60);
  const elapsedMinutes = Math.round(finishMinutes % 60);
  
  // Round to nearest 5-minute increment
  let roundedMinutes = Math.round(elapsedMinutes / 5) * 5;
  let roundedHours = elapsedHours;
  
  if (roundedMinutes === 60) {
    roundedHours++;
    roundedMinutes = 0;
  }
  
  // Format as H:MM for the key (ELAPSED time, not time of day)
  const timeKey = `${roundedHours}:${String(roundedMinutes).padStart(2, '0')}`;
  
  console.log(`Elapsed time: ${elapsedHours}:${String(elapsedMinutes).padStart(2, '0')}`);
  console.log(`Rounded elapsed time: ${timeKey}`);
  console.log(`Looking for key: "${timeKey}"`);
  console.log(`Available keys in finishClimateData:`, Object.keys(finishClimateData));
  
  // Get data for this time
  const climateForTime = finishClimateData[timeKey];
  
  if (!climateForTime) {
    console.warn(`Climate data not available for elapsed time ${timeKey}`);
    return;
  }
  
  // Update table with combined start + finish data
  const tbody = document.getElementById('climateBody');
  tbody.innerHTML = '';
  
  const finishStr = formatPacificTime(finishTime, true);
  const elapsedStr = `${roundedHours}:${String(roundedMinutes).padStart(2, '0')}`;
  
  // Update header to show finish time
  const finishHeaders = tbody.closest('table').querySelectorAll('th');
  finishHeaders[3].innerHTML = `Finish Temp (°F)<br><span style="font-weight:400; font-size:12px;">Sacramento, ${finishStr}</span>`;
  finishHeaders[4].innerHTML = `Finish Conditions<br><span style="font-weight:400; font-size:12px;">Sacramento, ${finishStr}</span>`;
  
  // Combine data by year
  startClimateData.forEach((startRow, i) => {
    const finishRow = climateForTime[i]; // Same year index
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${startRow.year}</td>
      <td>${startRow.temp}°F</td>
      <td>${startRow.conditions}</td>
      <td>${Math.round(finishRow.finish_temp)}°F</td>
      <td>${finishRow.finish_conditions}</td>`;
    tbody.appendChild(tr);
  });
}

document.addEventListener('DOMContentLoaded', loadClimatology);
</script>

<!-- ============ TERRAIN + ELEVATION ============ -->
<script>
function latLonToTileXY(lat, lon, z){
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const y = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
  return {x,y};
}
function latLonToPixelXYInTile(lat, lon, z, tileSize=256){
  const n = Math.pow(2, z);
  const xtile = (lon + 180) / 360 * n;
  const latRad = lat * Math.PI/180;
  const ytile = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n;
  const px = Math.floor((xtile - Math.floor(xtile)) * tileSize);
  const py = Math.floor((ytile - Math.floor(ytile)) * tileSize);
  return {px, py};
}
function decodeTerrainRGB(r,g,b){ return -10000 + (r*256*256 + g*256 + b) * 0.1; }

const tileCache = new Map();
async function getTileImageData(z,x,y){
  const key = `${z}/${x}/${y}`;
  if (tileCache.has(key)) return tileCache.get(key);
  const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${MAPBOX_TOKEN}`;
  const img = new Image(); img.crossOrigin = 'anonymous';
  const loaded = new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=(e)=>rej(e); });
  img.src = url; await loaded;
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
  const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
  const imageData = ctx.getImageData(0,0,256,256);
  const record = { imageData }; tileCache.set(key, record); return record;
}
async function getElevationMetersAt(lat, lon, z){
  const {x,y} = latLonToTileXY(lat, lon, z);
  const {px,py} = latLonToPixelXYInTile(lat, lon, z, 256);
  try{
    const { imageData } = await getTileImageData(z,x,y);
    const idx = (py*256 + px) * 4;
    const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
    return decodeTerrainRGB(r,g,b);
  }catch(e){ return null; }
}
function haversineMi(a,b){
  const R=3958.7613; const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLon=toRad(b[1]-a[1]); const la1=toRad(a[0]);
  const h=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

let elevChart = null, profileDistances = [], profileElevations = [], currentHighlightIndices = new Set();
function elevationAtMile(mile) {
  if (!profileDistances.length) return null;
  for (let i=1;i<profileDistances.length;i++) {
    if (profileDistances[i] >= mile) {
      const d0 = profileDistances[i-1], d1 = profileDistances[i];
      const e0 = profileElevations[i-1], e1 = profileElevations[i-1] == null ? null : profileElevations[i];
      if (e0==null || e1==null) return null;
      const t = (mile-d0)/(d1-d0);
      return e0 + t*(e1-e0);
    }
  }
  return profileElevations[profileElevations.length-1];
}
async function buildElevationProfile(routeCoords, z){
  const fullDistances = [0];
  for(let i=1;i<routeCoords.length;i++) fullDistances[i] = fullDistances[i-1] + haversineMi(routeCoords[i-1], routeCoords[i]);
  const sampled = [], sampledDistances = [];
  // Maximum detail: sample every point (i+=1)
  for (let i=0;i<routeCoords.length;i++){ sampled.push(routeCoords[i]); sampledDistances.push(fullDistances[i]); }
  const meters=[];
  for (const [lat,lon] of sampled){ meters.push(await getElevationMetersAt(lat,lon,z)); }
  const feet = meters.map(m => (m!=null ? m*3.28084 : null));
  return { distances: sampledDistances, elevations: feet, sampled };
}
function buildElevationChart(distances, elevations, stations){
  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevChart) elevChart.destroy();
  profileDistances = distances; profileElevations = elevations;
  const stationPoints = stations.map(s => ({ x: s.miles, y: elevationAtMile(s.miles) }));
  elevChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label:'Elevation', data: profileDistances.map((d,i)=>({x:d,y:elevations[i]})), parsing:false, borderColor:'#000', pointRadius:0, borderWidth:1.5, fill:false, tension:0.1 },
        {
          label:'Stations', type:'scatter', data: stationPoints, parsing:false, pointRadius:6, hoverRadius:10, hitRadius:12,
          pointBackgroundColor: (c) => {
            const idx = c.dataIndex;
            return (elevChart && currentHighlightIndices.has(idx))
              ? getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700'
              : getComputedStyle(document.documentElement).getPropertyValue('--blaze').trim() || '#37BC7D';
          },
          pointBorderColor:'#222', pointBorderWidth:1
        }
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } },
      plugins: {
        legend: { display:false },
        tooltip: {
          enabled: window.innerWidth > 768, 
          filter: ctx => ctx.datasetIndex === 1,
          external: (context) => {
            // Completely suppress tooltip rendering on mobile
            if (window.innerWidth <= 768) {
              const tooltipElement = document.querySelector('.chartjs-tooltip');
              if (tooltipElement) {
                tooltipElement.style.display = 'none';
                tooltipElement.style.opacity = '0';
                tooltipElement.style.pointerEvents = 'none';
              }
              return;
            }
          },
          callbacks: {
            title: (ctx) => {
              const station = stations[ctx[0].dataIndex];
              return `${station.name} – Mile ${station.miles.toFixed(1)}`;
            },
            label: (ctx) => {
              const station = stations[ctx.dataIndex];
              const pace = paceMinPerMiFromUI();
              const elapsed = formatElapsedFromMinutes(station.miles * pace);
              if (station.forecasts && station.forecasts.length) {
                return station.forecasts.map(f => [
                  `Elapsed: ${elapsed}`,
                  `ETA: ${formatPacificTime(f.eta, true)}`,
                  `Temp: ${f.temp}`, `Wind: ${f.wind}`, `Conditions: ${f.cond}`
                ]).flat();
              }
                return [`Elapsed: ${elapsed}`, "Forecast: –"];
            }
          },
          backgroundColor:'#fff',
          borderColor: getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700',
          borderWidth:2, titleColor:'#111', bodyColor:'#111', padding:8, displayColors:false
        }
      },
      interaction: { mode: window.innerWidth > 768 ? 'point' : 'none', intersect:true },
      onHover: (event, elements) => {
        const canvas = event.chart.canvas;
        const isMobile = window.innerWidth <= 768;
        
        if (elements.length > 0 && elements[0].datasetIndex === 1) {
          canvas.style.cursor = 'pointer';
          const idx = elements[0].index;
          highlightByStationIndex(idx);
        } else {
          canvas.style.cursor = 'default';
          clearHighlights();
          // Only update tooltip on desktop
          if (!isMobile) {
            event.chart.tooltip.setActiveElements([], {x:0,y:0});
            event.chart.update();
          }
        }
      },
      onClick: (event, elements) => {
        // When user clicks on a station point on the chart, show modal
        if (elements.length > 0 && elements[0].datasetIndex === 1) {
          const stationIdx = elements[0].index;
          const stations = raceConfig.allStations[currentStationOption];
          if (stations && stations[stationIdx]) {
            const station = stations[stationIdx];
            const elevation = elevationAtMile(station.miles);
            
            // Hide tooltip on mobile
            if (window.innerWidth <= 768) {
              if (elevChart && elevChart.tooltip) {
                elevChart.tooltip.setActiveElements([]);
                elevChart.tooltip.setOpacity(0);
              }
              document.querySelectorAll('.chartjs-tooltip').forEach(el => {
                el.style.display = 'none';
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
              });
            }
            
            showStationModal(station, elevation);
          }
        }
      },
      scales: {
        x: { type:'linear', title:{ display:true, text:'Distance (mi)' }, min:0, max:26.2 },
        y: { title:{ display:true, text:'Elevation (ft)' }, ticks:{ autoSkip:true, maxTicksLimit:6 } }
      }
    }
  });
  ctx.canvas.addEventListener("mouseleave", () => {
    if (elevChart) {
      // Only update tooltip on desktop
      if (window.innerWidth > 768) {
        elevChart.tooltip.setActiveElements([], {x:0,y:0});
        elevChart.update();
      }
      clearHighlights();
    }
  });
  
  // Hide tooltips on click on mobile
  ctx.canvas.addEventListener("click", () => {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.chartjs-tooltip').forEach(el => {
        el.style.display = 'none';
        el.style.visibility = 'hidden';
        el.style.opacity = '0';
      });
    }
  });
}
</script>

<!-- ============ MAP + MARKERS + FORECASTS ============ -->
<script>
async function getNOAAForecast(lat, lon, targetDate) {
  try {
    console.log(`=== NOAA DEBUG for lat:${lat}, lon:${lon} ===`);
    console.log(`Target ETA (UTC): ${targetDate.toISOString()}`);
    console.log(`Target ETA (Pacific): ${formatPacificTime(targetDate, true)}`);
    
    const pointRes = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    const pointData = await pointRes.json();
    const fRes = await fetch(pointData.properties.forecastHourly);
    const fData = await fRes.json();
    const periods=fData?.properties?.periods||[];
    if (!periods.length) return null;
    
    console.log(`First NOAA period: ${periods[0].startTime}`);
    console.log(`Searching ${periods.length} hourly forecasts...`);
    
    const closest = periods.reduce((p,c)=>
      Math.abs(new Date(c.startTime)-targetDate) < Math.abs(new Date(p.startTime)-targetDate) ? c : p
    );
    
    const matchTime = new Date(closest.startTime);
    const diffMinutes = Math.abs(matchTime - targetDate) / 60000;
    
    console.log(`NOAA MATCH FOUND:`);
    console.log(`  - NOAA time: ${closest.startTime}`);
    console.log(`  - Time difference: ${diffMinutes.toFixed(1)} minutes`);
    console.log(`  - Temperature: ${closest.temperature}°F`);
    console.log(`  - Conditions: ${closest.shortForecast}`);
    
    return closest;
  } catch (err) {
    console.error('NOAA fetch error:', err);
    return null;
  }
}

async function getOpenMeteoForecast(lat, lon, targetDate) {
  try {
    console.log(`=== OPEN-METEO DEBUG for lat:${lat}, lon:${lon} ===`);
    console.log(`Target ETA (UTC): ${targetDate.toISOString()}`);
    console.log(`Target ETA (Pacific): ${formatPacificTime(targetDate, true)}`);
    
    // Use America/Los_Angeles timezone explicitly for consistency
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,wind_speed_10m,wind_direction_10m,weather_code&temperature_unit=fahrenheit&wind_speed_unit=mph&timezone=America/Los_Angeles&forecast_days=16`;
    const res = await fetch(url);
    const data = await res.json();
    
    if (!data.hourly || !data.hourly.time) return null;
    
    // Parse times as Pacific timezone dates
    // Open-Meteo returns ISO strings WITHOUT timezone info (e.g., "2025-11-24T13:00")
    // Determine PST (-08:00) vs PDT (-07:00) based on month
    // PST: Nov-March, PDT: March-Nov (roughly)
    const times = data.hourly.time.map(t => {
      // Extract month from ISO string (format: YYYY-MM-DDTHH:MM)
      const month = parseInt(t.substring(5, 7));
      // PST months: 11, 12, 1, 2, 3 (Nov-Mar)
      // PDT months: 4, 5, 6, 7, 8, 9, 10 (Apr-Oct)
      const offset = (month >= 11 || month <= 3) ? '-08:00' : '-07:00';
      return new Date(t + offset);
    });
    
    // Find closest time to target
    let closestIdx = 0;
    let minDiff = Math.abs(times[0] - targetDate);
    
    console.log(`First Open-Meteo time: ${times[0].toISOString()} (${data.hourly.time[0]})`);
    console.log(`Searching ${times.length} hourly forecasts...`);
    
    for (let i = 1; i < times.length; i++) {
      const diff = Math.abs(times[i] - targetDate);
      if (diff < minDiff) {
        minDiff = diff;
        closestIdx = i;
      }
    }
    
    console.log(`MATCH FOUND at index ${closestIdx}:`);
    console.log(`  - Open-Meteo time string: ${data.hourly.time[closestIdx]}`);
    console.log(`  - Converted to Date: ${times[closestIdx].toISOString()}`);
    console.log(`  - Time difference: ${(minDiff / 60000).toFixed(1)} minutes`);
    console.log(`  - Temperature: ${data.hourly.temperature_2m[closestIdx]}°F`);
    
    // Warn if match is poor quality (>2 hours off)
    if (minDiff > 2 * 60 * 60 * 1000) {
      console.warn(`âš ï¸ WARNING: Matched forecast is ${(minDiff / 3600000).toFixed(1)} hours from target!`);
      console.warn(`This likely means the race is beyond Open-Meteo's forecast range.`);
      console.warn(`Open-Meteo free tier provides ~7 days of hourly forecasts.`);
    }
    
    const weatherCode = data.hourly.weather_code[closestIdx];
    const weatherDescriptions = {
      0: "Clear", 1: "Mainly Clear", 2: "Partly Cloudy", 3: "Overcast",
      45: "Foggy", 48: "Depositing Rime Fog",
      51: "Light Drizzle", 53: "Moderate Drizzle", 55: "Dense Drizzle",
      56: "Light Freezing Drizzle", 57: "Dense Freezing Drizzle",
      61: "Slight Rain", 63: "Moderate Rain", 65: "Heavy Rain",
      66: "Light Freezing Rain", 67: "Heavy Freezing Rain",
      71: "Slight Snow", 73: "Moderate Snow", 75: "Heavy Snow",
      77: "Snow Grains",
      80: "Slight Rain Showers", 81: "Moderate Rain Showers", 82: "Violent Rain Showers",
      85: "Slight Snow Showers", 86: "Heavy Snow Showers",
      95: "Thunderstorm", 96: "Thunderstorm with Slight Hail", 99: "Thunderstorm with Heavy Hail"
    };
    
    const temp = data.hourly.temperature_2m[closestIdx];
    const windSpeed = data.hourly.wind_speed_10m[closestIdx];
    const windDir = data.hourly.wind_direction_10m[closestIdx];
    const windDirCardinal = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(windDir / 22.5) % 16];
    
    return {
      temperature: Math.round(temp),
      windSpeed: `${Math.round(windSpeed)} mph`,
      windDirection: windDirCardinal,
      shortForecast: weatherDescriptions[weatherCode] || "Unknown",
      matchQualityMinutes: minDiff / 60000  // Return quality metric in minutes
    };
  } catch (err) {
    console.error('OpenMeteo error:', err);
    return null;
  }
}

function bindMarkerTooltip(marker) {
  // Only bind tooltips on desktop (> 768px)
  if (window.innerWidth > 768) {
    marker.bindTooltip("", { direction: "auto", offset: [0, -10], opacity: 0.95, className: "pp-tooltip", sticky: false, autoPan: true });
  }
}

// Aggressive tooltip suppression on mobile
if (window.innerWidth <= 768) {
  document.addEventListener('click', () => {
    // Remove all tooltips and popups immediately after any click
    setTimeout(() => {
      document.querySelectorAll('.leaflet-tooltip, .leaflet-popup, .chartjs-tooltip, .pp-tooltip').forEach(el => {
        el.remove();
      });
      // Also close any active Leaflet popups
      if (map && map._popup) {
        map.closePopup();
      }
    }, 0);
  }, true);  // Use capture phase to catch clicks early
}

// Disable all popups on mobile
if (window.innerWidth <= 768) {
  L.Marker.prototype.options.closePopupOnClick = true;
  
  // Disable popup opening entirely on mobile
  const originalOpenPopup = L.Marker.prototype.openPopup;
  L.Marker.prototype.openPopup = function() {
    if (window.innerWidth <= 768) {
      return this;  // Do nothing on mobile
    }
    return originalOpenPopup.call(this);
  };
}

const map = L.map('map', {
  keyboard: false,
  scrollWheelZoom: false,
  touchZoom: 'center',
  zoomControl: true,
  dragging: true
}).setView([38.60, -121.30], 11);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

// Hide tooltips on click on mobile
map.on('click', () => {
  if (window.innerWidth <= 768) {
    document.querySelectorAll('.leaflet-tooltip').forEach(el => {
      el.style.display = 'none';
      el.style.visibility = 'hidden';
      el.style.opacity = '0';
    });
  }
});

let markers = [];
let groupList = [];
let stationIndexToGroup = [];
let mapBounds = null;
window.mapReady = false;

function applyMarkerHighlights(activeGroupIdx){
  markers.forEach((m,i)=>{ const dot = m.getElement()?.querySelector('.blaze-dot'); if (dot) dot.classList.toggle("highlighted", i === activeGroupIdx); });
}
function applyChartHighlights(indices){
  currentHighlightIndices = new Set(indices);
  if (elevChart){ elevChart.setActiveElements(indices.map(i=>({datasetIndex:1,index:i}))); elevChart.update(); }
}
function highlightByStationIndex(stationIdx){
  const gIdx = stationIndexToGroup[stationIdx];
  applyMarkerHighlights(gIdx);
  applyChartHighlights([stationIdx]);
}
function highlightByGroupIndex(groupIdx){
  const indices = groupList[groupIdx].indices;
  applyMarkerHighlights(groupIdx);
  applyChartHighlights(indices);
}
function clearHighlights(){
  currentHighlightIndices.clear();
  markers.forEach(m=>m.getElement()?.querySelector('.blaze-dot')?.classList.remove("highlighted"));
  if(elevChart){ elevChart.setActiveElements([]); elevChart.update(); }
}
const blazeIcon = L.divIcon({ className:"", html:'<div class="blaze-dot"></div>', iconSize:[20,20], iconAnchor:[10,10] });

function tooltipLinesMapGroup(g, stations) {
  let html = "";
  g.indices.forEach((i, idx) => {
    const s = stations[i];
    if (idx > 0) html += `<hr style="margin:6px 0;">`
    const pace = paceMinPerMiFromUI();
    const elapsed = formatElapsedFromMinutes(s.miles * pace);
    html += `<div style="margin-bottom:6px;">
      <strong>${s.name}  – Mile ${s.miles.toFixed(1)}</strong><br>`;
    if (s.forecasts && s.forecasts.length) {
      s.forecasts.forEach(f => {
        html += `Elapsed: ${elapsed}<br>
                 ETA: ${formatPacificTime(f.eta, true)}<br>
                 Temp: ${f.temp}<br>
                 Wind: ${f.wind}<br>
                 Conditions: ${f.cond}<br>`;
      });
    } else {
      html += `Elapsed: ${elapsed}<br>Forecast: "–"<br>`;
    }
    html += `</div>`;
  });
  return html;
}

// ===== STATION MODAL =====
function showStationModal(station, elevation) {
  const modal = document.getElementById('stationModal');
  
  // Populate modal with station data
  document.getElementById('stationModalName').textContent = station.name;
  document.getElementById('stationModalDistance').textContent = `${station.miles.toFixed(1)} mi`;
  document.getElementById('stationModalElevation').textContent = elevation !== null ? `${Math.round(elevation)} ft` : 'N/A';
  document.getElementById('stationModalElapsed').textContent = station.elapsed || 'N/A';
  document.getElementById('stationModalETA').textContent = station.etaStr || 'N/A';
  document.getElementById('stationModalTemp').textContent = station.temp || '–';
  document.getElementById('stationModalWind').textContent = station.wind || '–';
  document.getElementById('stationModalCond').textContent = station.cond || '–';
  
  // Prevent body scroll when modal is open
  document.body.style.overflow = 'hidden';
  
  // Show modal
  modal.style.display = 'flex';
}

function closeStationModal() {
  document.getElementById('stationModal').style.display = 'none';
  // Re-enable body scroll
  document.body.style.overflow = 'auto';
}

// Close modal button handlers
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('stationModalClose').addEventListener('click', closeStationModal);
  document.getElementById('stationModalCloseBtn').addEventListener('click', closeStationModal);
  
  // Close modal when clicking outside (on the background)
  document.getElementById('stationModal').addEventListener('click', function(e) {
    if(e.target === this) closeStationModal();
  });
});

function redrawMarkers(option) {
  // Clear existing markers
  markers.forEach(m => m.remove());
  markers = [];
  groupList = [];
  stationIndexToGroup = [];
  
  const stations = raceConfig.allStations[option];
  if (!stations) return;
  
  // Group stations by lat/lon
  const groupsByKey = {};
  stations.forEach((s, idx) => {
    const key = `${s.lat},${s.lon}`;
    if (!groupsByKey[key]) groupsByKey[key] = { lat:s.lat, lon:s.lon, indices:[] };
    groupsByKey[key].indices.push(idx);
  });
  groupList = Object.values(groupsByKey);
  
  // Place markers
  groupList.forEach((g, gIdx) => {
    g.indices.forEach(stIdx => { stationIndexToGroup[stIdx] = gIdx; });
    const marker = L.marker([g.lat, g.lon], { icon: blazeIcon }).addTo(map);
    g.marker = marker;
    markers.push(marker);
    
    // On mobile, explicitly remove any tooltips
    if (window.innerWidth <= 768) {
      marker.unbindTooltip();
    } else {
      // On desktop, bind and set tooltip content
      bindMarkerTooltip(marker);
      marker.setTooltipContent(tooltipLinesMapGroup(g, stations));
    }
    
    marker.on("mouseover", () => highlightByGroupIndex(gIdx));
    marker.on("mouseout", clearHighlights);
    // Click handler to show station details modal
    marker.on("click", (e) => {
      // Prevent Leaflet popup/tooltip from showing on mobile
      if (window.innerWidth <= 768) {
        L.DomEvent.stopPropagation(e);
        
        // Close any popups/tooltips
        if (marker._popup) marker._popup.close();
        if (marker._tooltip) marker._tooltip.close();
        
        // Remove popup and tooltip entirely
        marker.unbindPopup();
        marker.unbindTooltip();
      }
      
      const primaryStationIdx = g.indices[0];
      const station = stations[primaryStationIdx];
      const elevation = elevationAtMile(station.miles);
      
      // Close any tooltip/popup on mobile
      if (window.innerWidth <= 768) {
        marker.closeTooltip();
        if (marker._popup) marker.closePopup();
        // Hide any tooltip/popup elements that might exist
        document.querySelectorAll('.leaflet-tooltip, .leaflet-popup').forEach(el => {
          el.style.display = 'none';
          el.style.visibility = 'hidden';
          el.style.opacity = '0';
        });
      }
      
      showStationModal(station, elevation);
    });
  });
}

// Load route and initial setup
fetch(raceConfig.routeUrl).then(r=>r.json()).then(async(route)=>{
  raceConfig.route = route;
  
  const line = L.polyline(route, {color:"#000", weight:3}).addTo(map);
  mapBounds = line.getBounds();
  map.fitBounds(mapBounds, {padding: [30, 30]});
  
  // Build elevation
  try {
    const {distances, elevations} = await buildElevationProfile(route, raceConfig.elevationZoom);
    profileDistances = distances;
    profileElevations = elevations;
    
    // Load mile markers (option1) by default and display on map and elevation
    const stations1 = await fetch(raceConfig.stationUrls.option1).then(r => r.json());
    raceConfig.allStations = { option1: stations1 };
    
    // Draw markers on map
    redrawMarkers('option1');
    
    // Build elevation chart with mile markers
    buildElevationChart(profileDistances, profileElevations, stations1);
    
  } catch(e) {
    console.error('Elevation error', e);
    const distances = [0];
    for(let i=1; i<route.length; i++) distances[i] = distances[i-1] + haversineMi(route[i-1], route[i]);
    profileDistances = distances;
    profileElevations = distances.map(() => 100);
  }
  
  window.mapReady = true;
  
  // Collapse map and elevation sections after they're fully loaded
  document.getElementById('mapContent').style.display = 'none';
  document.getElementById('mapToggle').textContent = '+';
  document.getElementById('elevContent').style.display = 'none';
  document.getElementById('elevToggle').textContent = '+';
});

async function updateForecastsForOption(opt, sourceToFetch = 'both', progressCallback = null){
  const pace = paceMinPerMiFromUI();
  const now = new Date();
  const noaaHorizonHours = 6.5 * 24;
  const openMeteoHorizonHours = 16 * 24;
  
  console.log(`\n📡 updateForecastsForOption(${opt}, sourceToFetch='${sourceToFetch}')`);
  
  // Only set labels on first option load
  if (opt === 'option1') {
    const validLabel = document.getElementById("forecastValidLabel");
    const dateLabel = document.getElementById("forecastDateLabel");
    const sourceMethodLabel = document.getElementById("forecastSourceMethodLabel");

    // Determine if we can fetch both sources
    let minHrs = Infinity;
    let maxHrs = -Infinity;
    const stations = raceConfig.allStations[opt];
    for (const s of stations) {
      const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
      const hrs = (eta - now) / 3_600_000;
      if (hrs < minHrs) minHrs = hrs;
      if (hrs > maxHrs) maxHrs = hrs;
    }

    // Check if we should fetch both sources
    bothSourcesAvailable = (minHrs <= noaaHorizonHours);
    
    console.log(`Race is ${minHrs.toFixed(1)} hours away. NOAA available: ${minHrs <= noaaHorizonHours}, Both sources: ${bothSourcesAvailable}`);

    // Get current time for display - LOCAL (user device time)
    const now_str_local = new Date().toLocaleString('en-US', { 
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });

    if (minHrs <= noaaHorizonHours) {
      validLabel.textContent = `Generated: ${now_str_local}`;
      dateLabel.textContent = `Forecast Range: ${minHrs.toFixed(1)} to ${maxHrs.toFixed(1)} hours ahead`;
      sourceMethodLabel.textContent = `Current: ${currentForecastSource === 'noaa' ? 'NOAA forecastHourly (6.5 day range)' : 'Open-Meteo API (16 day range)'}`;
    } else if (minHrs <= openMeteoHorizonHours) {
      validLabel.textContent = `Generated: ${now_str_local}`;
      dateLabel.textContent = `Forecast Range: ${minHrs.toFixed(1)} to ${maxHrs.toFixed(1)} hours ahead`;
      sourceMethodLabel.textContent = `Using: Open-Meteo API (extended forecast via ensemble models)`;
    } else {
      validLabel.textContent = ``;
      dateLabel.textContent = ``;
      sourceMethodLabel.textContent = ``;
    }
  }


  // Generate forecasts for this option only
  const stations = raceConfig.allStations[opt];
  console.log(`Fetching ${sourceToFetch === 'both' ? 'BOTH sources' : sourceToFetch.toUpperCase()} for ${stations.length} stations`);
  
  // Create array of fetch promises - all requests execute in parallel!
  const fetchPromises = stations.map(async (s, i) => {
    const elapsedStr = formatElapsedFromMinutes(s.miles * pace);
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const timeStr = formatPacificTime(eta, true);
    const hoursUntilEta = (eta - now) / 3_600_000;

    if (!s.noaaForecast) s.noaaForecast = null;
    if (!s.openMeteoForecast) s.openMeteoForecast = null;

    // Build array of forecast requests to fetch in parallel
    const forecastRequests = [];
    
    // Log the decision for first few stations
    if (i < 2) {
      console.log(`  ${s.name}: ETA in ${hoursUntilEta.toFixed(1)} hours (${hoursUntilEta > noaaHorizonHours ? '❌ NOAA unavailable' : '✓ NOAA available'})`);
    }
    
    if ((sourceToFetch === 'noaa' || sourceToFetch === 'both') && hoursUntilEta <= noaaHorizonHours) {
      forecastRequests.push(
        getNOAAForecast(s.lat, s.lon, eta).then(f => {
          if (f) {
            const temp = f.temperature != null ? `${f.temperature}°F` : "-";
            const speed = f.windSpeed || "", dir = f.windDirection || "";
            const wind = (speed || dir) ? `${speed} ${dir}`.trim() : "-";
            const cond = f.shortForecast || "-";
            s.noaaForecast = { temp, wind, cond, raw: f };
          } else {
            s.noaaForecast = { temp: "-", wind: "-", cond: "Forecast unavailable", raw: null };
          }
        }).catch(err => {
          console.error('NOAA fetch error for', s.name, err);
          s.noaaForecast = { temp: "-", wind: "-", cond: "Error", raw: null };
        })
      );
    } else if ((sourceToFetch === 'noaa' || sourceToFetch === 'both') && hoursUntilEta > noaaHorizonHours) {
      // NOAA not available for this station
      s.noaaForecast = { temp: "-", wind: "-", cond: "Beyond NOAA range", raw: null };
    }

    if ((sourceToFetch === 'openmeteo' || sourceToFetch === 'both') && hoursUntilEta <= openMeteoHorizonHours) {
      forecastRequests.push(
        getOpenMeteoForecast(s.lat, s.lon, eta).then(f => {
          if (f) {
            // Always extract the actual forecast data
            const temp = f.temperature != null ? `${f.temperature}°F` : "-";
            const speed = f.windSpeed || "", dir = f.windDirection || "";
            const wind = (speed || dir) ? `${speed} ${dir}`.trim() : "-";
            const cond = f.shortForecast || "-";
            
            // Store forecast with match quality info
            const matchQuality = f.matchQualityMinutes || 0;
            s.openMeteoForecast = { 
              temp, 
              wind, 
              cond,
              matchQuality,  // Store for reference
              raw: f 
            };
          } else {
            s.openMeteoForecast = { temp: "-", wind: "-", cond: "Forecast unavailable", raw: null };
          }
        }).catch(err => {
          console.error('Open-Meteo fetch error for', s.name, err);
          s.openMeteoForecast = { temp: "-", wind: "-", cond: "Error", raw: null };
        })
      );
    }

    // Wait for all forecast requests for this station
    await Promise.all(forecastRequests);

    // Set default display values based on current source and availability
    let displayForecast;
    
    // Simple logic: use the selected source if it has data, otherwise fall back
    if (currentForecastSource === 'noaa' && s.noaaForecast && s.noaaForecast.temp !== '-') {
      displayForecast = s.noaaForecast;
    } else if (currentForecastSource === 'openmeteo' && s.openMeteoForecast && s.openMeteoForecast.temp !== '-') {
      displayForecast = s.openMeteoForecast;
    } else if (s.openMeteoForecast && s.openMeteoForecast.temp !== '-') {
      // Fallback to Open-Meteo if selected source doesn't have data
      displayForecast = s.openMeteoForecast;
    } else if (s.noaaForecast && s.noaaForecast.temp !== '-') {
      // Fallback to NOAA if selected source doesn't have data
      displayForecast = s.noaaForecast;
    } else {
      // No data available
      displayForecast = { temp: "-", wind: "-", cond: "Data unavailable" };
    }

    s.elapsed = elapsedStr;
    s.etaStr = timeStr;
    s.temp = displayForecast.temp;
    s.wind = displayForecast.wind;
    s.cond = displayForecast.cond;
    s.forecasts = [{ eta, temp: displayForecast.temp, wind: displayForecast.wind, cond: displayForecast.cond, elapsed: elapsedStr }];
    
    return i;
  });

  // Execute all station forecasts in parallel and track progress
  let completedCount = 0;
  fetchPromises.forEach(promise => {
    promise.then(() => {
      completedCount++;
      if (progressCallback && opt === currentStationOption) {
        progressCallback(completedCount, stations.length);
      }
    });
  });
  
  // Wait for all stations to complete
  await Promise.all(fetchPromises);

  // Check which sources have valid data
  noaaHasValidData = false;
  openMeteoHasValidData = false;
  
  for (const s of stations) {
    // Check if NOAA has valid data (not an error state)
    if (s.noaaForecast && s.noaaForecast.cond && 
        s.noaaForecast.cond !== 'Error' && 
        s.noaaForecast.cond !== 'Forecast unavailable' &&
        s.noaaForecast.cond !== 'Beyond NOAA range' &&
        s.noaaForecast.temp !== '-') {
      noaaHasValidData = true;
    }
    
    // Check if Open-Meteo has valid data (not an error state)
    if (s.openMeteoForecast && s.openMeteoForecast.cond && 
        s.openMeteoForecast.cond !== 'Error' && 
        s.openMeteoForecast.cond !== 'Forecast unavailable' &&
        s.openMeteoForecast.temp !== '-') {
      openMeteoHasValidData = true;
    }
  }
  
  console.log(`Forecast sources available - NOAA: ${noaaHasValidData}, Open-Meteo: ${openMeteoHasValidData}`);
  
  // Rebuild source toggle buttons with correct enabled/disabled state
  if (opt === 'option1') {
    buildSourceToggle();
  }

}
</script>

<!-- ============ Row highlighting ============ -->
<script>
function toggleDataSources() {
  const content = document.getElementById('sourcesContent');
  const toggle = document.getElementById('sourcesToggle');
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '−';
  } else {
    content.style.display = 'none';
    toggle.textContent = '+';
  }
}

function toggleClimatology() {
  const content = document.getElementById('climoContent');
  const toggle = document.getElementById('climoToggle');
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '−';
  } else {
    content.style.display = 'none';
    toggle.textContent = '+';
  }
}

function toggleForecast() {
  const content = document.getElementById('forecastContent');
  const toggle = document.getElementById('forecastToggle');
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '−';
  } else {
    content.style.display = 'none';
    toggle.textContent = '+';
  }
}

function toggleMap() {
  const content = document.getElementById('mapContent');
  const toggle = document.getElementById('mapToggle');
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '−';
    // Trigger map resize if Leaflet is ready
    if (window.map) {
      setTimeout(() => {
        map.invalidateSize();
        if (mapBounds) {
          map.fitBounds(mapBounds, {padding: [30, 30]});
        }
      }, 100);
    }
  } else {
    content.style.display = 'none';
    toggle.textContent = '+';
  }
}

function toggleElevation() {
  const content = document.getElementById('elevContent');
  const toggle = document.getElementById('elevToggle');
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '−';
    // Trigger chart redraw if needed
    if (window.elevChart) {
      setTimeout(() => window.elevChart.resize(), 100);
    }
  } else {
    content.style.display = 'none';
    toggle.textContent = '+';
  }
}

// Start with sections collapsed
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('sourcesContent').style.display = 'none';
  document.getElementById('sourcesToggle').textContent = '+';
  
  document.getElementById('climoContent').style.display = 'none';
  document.getElementById('climoToggle').textContent = '+';
  
  document.getElementById('forecastContent').style.display = 'none';
  document.getElementById('forecastToggle').textContent = '+';
  // Note: mapContent and elevContent are collapsed after map finishes loading
});

function installRowHighlighting() {
  const attach = (tbody) => {
    if (!tbody) return;
    tbody.addEventListener("pointerup", (e) => {
      const tr = e.target.closest("tr");
      if (!tr) return;
      const table = tr.closest("table");
      const was = tr.classList.contains("highlight-row");
      table.querySelectorAll("tbody tr").forEach(r => r.classList.remove("highlight-row"));
      if (!was) tr.classList.add("highlight-row");
    }, { passive: true });
  };
  attach(document.getElementById("forecastBody"));
  const observer = new MutationObserver(() => {
    document.querySelectorAll(".climoBody").forEach(attach);
  });
  observer.observe(document.getElementById("climatology"), { childList: true, subtree: true });
}
document.addEventListener("DOMContentLoaded", installRowHighlighting);
</script>
</html>
