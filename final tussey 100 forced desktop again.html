<head>
  <meta charset="UTF-8" />
  <!-- Force desktop layout, allow pinch-zoom/pan -->
  <meta name="viewport" content="width=1000, user-scalable=yes, initial-scale=1.0, maximum-scale=5.0" />

  <title id="pageTitle">Tussey mOUnTaiNBACK 100 Mile Ultramarathon | Peak Pace</title>

  <!-- ==== Libraries ==== -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <!-- ==== Styles ==== -->
  <style>
    /* === Force desktop layout on all devices === */
    html, body {
      min-width: 1000px !important;
      overflow-x: auto !important;
      touch-action: pan-x pan-y !important;
      zoom: 1 !important;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "Source Sans Pro", Arial, sans-serif;
      color: #111;
      background: #fff;
      line-height: 1.5;
    }

    :root {
      --ink: #111;
      --muted: #555;
      --line: #ddd;
      --pp-dark: #003546;
      --blaze: #37BC7D;
      --highlight: #FF6700;
      --hoverRow: #fff3e6;
    }

    .page-wrapper {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 10px;
    }

    /* ==== Header ==== */
    header {
      text-align: center;
      margin: 28px auto 14px;
    }
    header h2 {
      margin: 0;
      font-size: 32px;
      font-weight: 700;
    }
    #countdown {
      font-size: 20px;
      font-weight: 600;
      margin-top: 6px;
      color: #333;
    }
    #forecastStatus {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    /* ==== Card-style sections ==== */
    section,
    #elevSection {
      width: 100%;
      margin: 18px 0 0 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      padding: 16px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    section:last-of-type { margin-bottom: 24px; }
    section h3 {
      text-align: center;
      margin: 0 0 12px;
      font-size: 20px;
      font-weight: 700;
    }

    /* ==== Tables ==== */
    table { width: 100%; border-collapse: collapse; }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
      font-size: 14px;
    }
    th { background: #f0f0f0; font-weight: 700; }

    #climoAvg25, #climoAvg26 {
      font-weight: 700;
      background: #f5f5f5;
    }

    #forecastBody tr:hover,
    #climoBody25 tr:hover,
    #climoBody26 tr:hover {
      background: var(--hoverRow);
    }

    .note {
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      color: var(--muted);
    }

    /* ==== Target Pace Box ==== */
    #paceBox { 
      text-align: center; 
      padding: 8px; 
      margin: 6px 0; 
      background: #fff; 
      border: 1px solid #ccc; 
      border-radius: 8px; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.08); 
    }
    #paceControls {
      display: flex;
      gap: 4px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    #paceBox select, #paceBox button { font-size: 13px; padding: 4px 6px; }
    #paceGo, #toggleUnits {
      border: 1px solid var(--pp-dark);
      border-radius: 6px;
      color: #fff;
      background: var(--pp-dark);
      cursor: pointer;
    }

    /* ==== Map ==== */
    #map { 
      width: 100%; 
      height: 600px; 
      margin: 10px 0 0 0; 
      border: 1px solid #ccc; 
      border-radius: 8px; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.08); 
    }
    .leaflet-marker-icon {
      cursor: pointer;
      transition: transform 150ms ease;
    }
    .leaflet-marker-icon:hover { transform: scale(1.2); }

    /* ==== Elevation Chart ==== */
    #elevWrap { 
      width: 100%; 
      position: relative; 
      height: 225px;
      margin-top: 10px; 
    }
    #elevationChart { 
      position: absolute; 
      inset: 0; 
      cursor: pointer; 
    }

    /* ==== WBGT ==== */
    .wbgt-low { color: #2e7d32; }
    .wbgt-mod { color: #f9a825; }
    .wbgt-high { color: #f57c00; }
    .wbgt-very { color: #c62828; }
    .wbgt-extreme { background: #ffb3b3; color: #000; font-weight: 700; }
    .wbgt-na { color: var(--muted); }

    /* ==== Blaze markers ==== */
    .blaze-dot {
      width: 20px;
      height: 20px;
      background: var(--blaze);
      border: 2px solid #222;
      border-radius: 50%;
      transition: transform 0.2s ease;
      transform-origin: center center;
    }
    .blaze-dot:hover { transform: scale(1.4); cursor: pointer; }
    .blaze-dot.highlighted {
      transform: scale(1.6);
      background: var(--highlight);
    }
    .highlight-row { background: var(--hoverRow) !important; }

    /* ==== Tooltips ==== */
    .leaflet-tooltip,
    .pp-tooltip {
      background: #fff;
      border: 2px solid var(--highlight);
      border-radius: 8px;
      color: var(--ink);
      font-size: 13px;
      font-weight: 500;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      padding: 6px 10px;
    }

    /* ==== Layout ==== */
    #map, #elevWrap, section { box-sizing: border-box; width: 100%; }
    .scroll-table { width: 100%; box-sizing: border-box; overflow-x: auto; }
    .scroll-table table { width: 100%; border-collapse: collapse; table-layout: fixed; }

    /* ==== Leaflet controls ==== */
    .leaflet-control { border: none !important; background: none !important; }
    .leaflet-control a,
    .leaflet-bar a,
    .leaflet-bar a:hover {
      background-color: var(--pp-dark) !important;
      color: #fff !important;
      border: 1px solid var(--pp-dark) !important;
      width: 30px !important;
      height: 30px !important;
      line-height: 30px !important;
      text-align: center;
      font-size: 16px;
    }
    .leaflet-control a:hover {
      background-color: var(--blaze) !important;
      border-color: var(--blaze) !important;
    }

    /* ==== Pace button flash ==== */
    @keyframes flashBlaze {
      0%   { background-color: var(--pp-dark); }
      20%  { background-color: var(--blaze); }
      80%  { background-color: var(--blaze); }
      100% { background-color: var(--pp-dark); }
    }
    #paceGo.flash { animation: flashBlaze 0.8s ease; }

    /* ==== Climatology Tabs ==== */
    #climoTabs {
      display: flex;
      justify-content: center;
      margin-bottom: 12px;
      gap: 8px;
    }
    .climoTab {
      padding: 6px 14px;
      border: 1px solid var(--pp-dark);
      border-radius: 6px 6px 0 0;
      background: #f9f9f9;
      color: var(--pp-dark);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .climoTab:hover { background: var(--hoverRow); }
    .climoTab.active {
      background: var(--pp-dark);
      color: #fff;
    }
    .climoPanel { display: none; }
    .climoPanel.active { display: block; }
  </style>
</head>




























<body>
<div class="page-wrapper">

<header>
  <h2 id="raceName"></h2>
  <div id="countdown">Loading countdownâ€¦</div>
</header>

<section id="climatology">
  <h3>Climatology â€“ Boalsburg, PA</h3>

  <!-- Tab buttons -->
  <div id="climoTabs">
    <button class="climoTab active" data-day="25">Oct 25</button>
    <button class="climoTab" data-day="26">Oct 26</button>
  </div>

  <!-- Panels -->
  <div id="climoPanels">
    <!-- Oct 25 Panel -->
    <div class="climoPanel active" id="climo25">
      <table>
        <thead>
          <tr>
            <th>Year</th>
            <th>Max Temp (Â°F)</th>
            <th>Min Temp (Â°F)</th>
            <th>Precipitation (")</th>
            <th>Conditions</th>
          </tr>
        </thead>
        <tbody id="climoBody25"></tbody>
        <tfoot>
          <tr id="climoAvg25">
            <td>Averages</td><td>â€”</td><td>â€”</td><td>â€”</td><td>â€”</td>
          </tr>
        </tfoot>
      </table>
      <div class="note">
  Historical climatology values are based on ASOS data from KUNV (University Park Airport), 
  located approximately 7 miles from Boalsburg, PA. Local variations in elevation, topography, 
  and vegetation may cause actual race-day conditions to differ from those observed at KUNV. 
  Data are provided for general planning purposes only and do not represent an official forecast.
</div>

    </div>

    <!-- Oct 26 Panel -->
    <div class="climoPanel" id="climo26">
      <table>
        <thead>
          <tr>
            <th>Year</th>
            <th>Max Temp (Â°F)</th>
            <th>Min Temp (Â°F)</th>
            <th>Precipitation (")</th>
            <th>Conditions</th>
          </tr>
        </thead>
        <tbody id="climoBody26"></tbody>
        <tfoot>
          <tr id="climoAvg26">
            <td>Averages</td><td>â€”</td><td>â€”</td><td>â€”</td><td>â€”</td>
          </tr>
        </tfoot>
      </table>
      <div class="note">
  Historical climatology values are based on ASOS data from KUNV (University Park Airport), 
  located approximately 7 miles from Boalsburg, PA. Local variations in elevation, topography, 
  and vegetation may cause actual race-day conditions to differ from those observed at KUNV. 
  Data are provided for general planning purposes only and do not represent an official forecast.
</div>
    </div>
  </div>
</section>



<div id="paceBox">
  <div id="paceControls">
    <label for="paceMin" id="paceLabel">Target Pace (min/mi):</label>
    <select id="paceMin"></select> : <select id="paceSec"></select>
    <button id="paceGo">Submit</button>
    <span id="paceConfirm" style="margin-left:8px; font-size:13px; color:var(--muted);"></span>
  </div>
</div>


<div id="map"></div>

<section id="elevSection">
  <div id="elevWrap"><canvas id="elevationChart"></canvas></div>
</section>

<section id="summary">
  <h3 id="tableHeader" style="margin-bottom:0;">Peak Pace Forecast</h3>
  <div id="forecastValidLabel" 
       style="font-size:12px; color:#555; margin:4px 0 6px; text-align:center;">
    Checking forecast windowâ€¦
  </div>
  <table>
    <thead>
      <tr>
        <th>Station</th>
        <th>Distance (mi)</th>
        <th>ETA</th>
        <th>Temp (Â°F)</th>
        <th>Wind</th>
        <th>Conditions</th>
        <th>WBGT</th>
      </tr>
    </thead>
    <tbody id="forecastBody"></tbody>
  </table>
  <div class="note" id="forecastNote">Forecasts available within 7 days of race.</div>
</section>


<section id="sources">
  <h3>Data Sources</h3>
  <ul style="font-size:13px; color:#555; line-height:1.5;">
    <li>Climatology: Iowa State University 
      <a href="https://mesonet.agron.iastate.edu/request/download.phtml" target="_blank" rel="noopener">IEM ASOS Archive</a>
    </li>
    <li>Elevation: Mapbox Terrain-RGB</li>
    <li>Weather Forecasts: NOAA/NWS API</li>
    <li>WBGT categories & regional thresholds: NOAA/NWS 
      <a href="https://digital.weather.gov/staticpages/definitions.php" target="_blank" rel="noopener">WBGT Definitions</a>
    </li>
  </ul>
  <div class="note" style="font-size:12px; color:#555; margin-top:6px;">
    WBGT values shown here are <b>approximations</b>, derived from NOAA temperature and relative humidity using the Stull (2011) wet-bulb formula. 
    They represent shaded WBGT and do not fully account for direct sunlight, wind, or radiant heat. 
    On-field measurements may differ.
  </div>
</section>


</div>
</body>
























<script>
/* ========= CONFIG ========= */
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGlsbG9uZHVyaW5pY2siLCJhIjoiY21memtlbm83MDNycTJtb3JtdGxucWpkMiJ9.W7Ge6XYCd0Gfl9f7YQ2dNw";

const raceConfig = {
  name: "Tussey mOUnTaiNBACK 100 Mile Ultramarathon",
  date: new Date("2025-10-05T18:30-04:00"),
  routeUrl: "https://raw.githubusercontent.com/dillondurinick/peakpaceweather/refs/heads/main/100routetussey2025.json",
  stationsUrl: "https://raw.githubusercontent.com/dillondurinick/peakpaceweather/refs/heads/main/100aidstationstussey2025.json",
  elevationZoom: 12,
  routeSampleStep: 20,
  regionCategory: 1
};

document.getElementById("raceName").textContent = raceConfig.name;
document.getElementById("pageTitle").textContent = `${raceConfig.name} | Peak Pace`;
const raceDate = raceConfig.date;

/* ========= COUNTDOWN ========= */
function updateCountdown() {
  const diff = raceConfig.date - new Date();
  const el = document.getElementById("countdown");
  const raceStartStr = raceConfig.date.toLocaleString([], { month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
  if (diff <= 0) { el.textContent = "RACE DAY IS HERE!"; return; }
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  el.textContent = days === 1
    ? `1 DAY UNTIL RACE DAY (${raceStartStr})`
    : `${days} DAYS UNTIL RACE DAY (${raceStartStr})`;
}
setInterval(updateCountdown, 60000); updateCountdown();

/* ========= UNITS / PACE ========= */
// Imperial only (mi, ft, min/mi)
function formatDist(mi){ return `${mi.toFixed(1)} mi`; }
function formatElev(ft){ return `${Math.round(ft)} ft`; }

function paceMinPerMiFromUI(){
  const m = Number(document.getElementById('paceMin').value) || 0;
  const s = Number(document.getElementById('paceSec').value) || 0;
  return m + s/60; // always minutes per mile
}

(function initPace(){
  const mins=document.getElementById('paceMin'), secs=document.getElementById('paceSec');
  for(let m=4;m<=30;m++){ 
    let o=document.createElement('option'); 
    o.value=m; o.textContent=m; 
    mins.appendChild(o); 
  }
  for(let s=0;s<60;s++){ 
    let o=document.createElement('option'); 
    o.value=s; o.textContent=String(s).padStart(2,'0'); 
    secs.appendChild(o); 
  }
  mins.value=10; secs.value=0;

  function showPaceConfirm(){
    const paceM = String(mins.value).padStart(2,"0");
    const paceS = String(secs.value).padStart(2,"0");
    const el = document.getElementById("paceConfirm");
    el.textContent = `Pace set to ${paceM}:${paceS} min/mi`;
  }

// Submit button
const paceBtn = document.getElementById('paceGo');

paceBtn.addEventListener("mousedown", () => {
  paceBtn.style.backgroundColor =
    getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700';
});

paceBtn.addEventListener("mouseup", () => {
  paceBtn.style.backgroundColor = "var(--pp-dark)";
  updateForecasts();
  showPaceConfirm();
});

paceBtn.addEventListener("mouseleave", () => {
  paceBtn.style.backgroundColor = "var(--pp-dark)";
});

  // Show default pace confirmation immediately on page load
  showPaceConfirm();
})();

/* ========= NOAA FORECAST ========= */
async function getNOAAForecast(lat, lon, targetDate) {
  try {
    const pointRes = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    const pointData = await pointRes.json();
    const fRes = await fetch(pointData.properties.forecastHourly);
    const fData = await fRes.json();
    const periods=fData?.properties?.periods||[];
    if (!periods.length) return null;
    return periods.reduce((p,c)=>
      Math.abs(new Date(c.startTime)-targetDate) < Math.abs(new Date(p.startTime)-targetDate) ? c : p
    );
  } catch { return null; }
}

/* ========= WBGT HELPERS ========= */
function wbgtClass(valF, category=1){
  if (valF==null) return {label:"â€”",cls:"wbgt-na",desc:"No data"};
  if (valF<82) return {label:`${valF.toFixed(0)}Â° Low`,cls:"wbgt-low",desc:"Safe"};
  if (valF<85) return {label:`${valF.toFixed(0)}Â° Mod`,cls:"wbgt-mod",desc:"Caution"};
  if (valF<88) return {label:`${valF.toFixed(0)}Â° High`,cls:"wbgt-high",desc:"High risk"};
  if (valF<90) return {label:`${valF.toFixed(0)}Â° Very High`,cls:"wbgt-very",desc:"Very high risk"};
  return {label:`${valF.toFixed(0)}Â° Extreme`,cls:"wbgt-extreme",desc:"Extreme risk"};
}
function toC(f){return(f-32)*5/9;} 
function toF(c){return c*9/5+32;}
function wetBulbC(Tc,RH){ 
  if(isNaN(Tc)||isNaN(RH)) return null;
  const Tw=Tc*Math.atan(0.151977*Math.sqrt(RH+8.313659))+Math.atan(Tc+RH)-Math.atan(RH-1.676331)+0.00391838*Math.pow(RH,1.5)*Math.atan(0.023101*RH)-4.686035;
  return Tw;
}
function wbgtShadeF(Tf,RH){const Tw=wetBulbC(toC(Tf),RH); return Tw?toF(Tw):null;}
function daysUntilRace(){return Math.floor((raceConfig.date-new Date())/(1000*60*60*24));}

/* ========= TERRAIN-RGB ========= */
function latLonToTileXY(lat, lon, z){
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const y = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
  return {x,y};
}
function latLonToPixelXYInTile(lat, lon, z, tileSize=256){
  const n = Math.pow(2, z);
  const xtile = (lon + 180) / 360 * n;
  const latRad = lat * Math.PI/180;
  const ytile = (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n;
  const px = Math.floor((xtile - Math.floor(xtile)) * tileSize);
  const py = Math.floor((ytile - Math.floor(ytile)) * tileSize);
  return {px, py};
}
function decodeTerrainRGB(r,g,b){ return -10000 + (r*256*256 + g*256 + b) * 0.1; }

const tileCache = new Map();
async function getTileImageData(z,x,y){
  const key = `${z}/${x}/${y}`;
  if (tileCache.has(key)) return tileCache.get(key);
  const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${MAPBOX_TOKEN}`;
  const img = new Image(); img.crossOrigin = 'anonymous';
  const loaded = new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=(e)=>rej(e); });
  img.src = url; await loaded;
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
  const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
  const imageData = ctx.getImageData(0,0,256,256);
  const record = { imageData }; tileCache.set(key, record); return record;
}
async function getElevationMetersAt(lat, lon, z){
  const {x,y} = latLonToTileXY(lat, lon, z);
  const {px,py} = latLonToPixelXYInTile(lat, lon, z, 256);
  try{
    const { imageData } = await getTileImageData(z,x,y);
    const idx = (py*256 + px) * 4;
    const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
    return decodeTerrainRGB(r,g,b);
  }catch(e){ return null; }
}
function haversineMi(a,b){
  const R=3958.7613; const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLon=toRad(b[1]-a[1]); const la1=toRad(a[0]);
  const h=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

/* ========= CLIMATOLOGY TABLE ========= */
function populateClimoTable(data, bodyId, avgId) {
  const body = document.getElementById(bodyId);
  body.innerHTML = "";

  let sumMax = 0, sumMin = 0, sumPrecip = 0, count = 0;

  data.forEach(row => {
    const max = Number(row.max);
    const min = Number(row.min);
    const precip = Number(row.precip);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.year}</td>
      <td>${isNaN(max) ? "â€”" : max.toFixed(1)}</td>
      <td>${isNaN(min) ? "â€”" : min.toFixed(1)}</td>
      <td>${isNaN(precip) ? "â€”" : precip.toFixed(2)}</td>
      <td>${row.conditions || "â€”"}</td>
    `;
    body.appendChild(tr);

    if (!isNaN(max)) sumMax += max;
    if (!isNaN(min)) sumMin += min;
    if (!isNaN(precip)) sumPrecip += precip;
    count++;
  });

  // Fill averages row
  const avgRow = document.getElementById(avgId);
  if(count > 0){
    avgRow.innerHTML = `
      <td>Averages</td>
      <td>${(sumMax/count).toFixed(1)}</td>
      <td>${(sumMin/count).toFixed(1)}</td>
      <td>${(sumPrecip/count).toFixed(2)}</td>
      <td>â€”</td>
    `;
  }
}

async function loadClimatology() {
  try {
    const [res25, res26] = await Promise.all([
      fetch("https://raw.githubusercontent.com/dillondurinick/peakpaceweather/refs/heads/main/October_25_Climate.json"),
      fetch("https://raw.githubusercontent.com/dillondurinick/peakpaceweather/refs/heads/main/October_26_Climate.json")
    ]);

    if (!res25.ok || !res26.ok) throw new Error("Bad response");

    const data25 = await res25.json();
    const data26 = await res26.json();

    populateClimoTable(data25, "climoBody25", "climoAvg25");
    populateClimoTable(data26, "climoBody26", "climoAvg26");
  } catch (err) {
    console.error("Failed to load climatology:", err);
    document.getElementById("climoBody25").innerHTML =
      `<tr><td colspan="5">Climatology data unavailable</td></tr>`;
    document.getElementById("climoBody26").innerHTML =
      `<tr><td colspan="5">Climatology data unavailable</td></tr>`;
  }
}

/* ========= TAB SWITCHING ========= */
document.querySelectorAll(".climoTab").forEach(btn => {
  btn.addEventListener("click", () => {
    // Tabs
    document.querySelectorAll(".climoTab").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");

    // Panels
    const day = btn.dataset.day;
    document.querySelectorAll(".climoPanel").forEach(p => p.classList.remove("active"));
    document.getElementById("climo" + day).classList.add("active");
  });
});

// Auto-run on page load
loadClimatology();


</script>


























<script>
/* ========= MAP TOOLTIP BINDER ========= */
function bindMarkerTooltip(marker) {
  marker.bindTooltip("", { 
    direction: "auto",
    offset: [0, -10],
    opacity: 0.95,
    className: "pp-tooltip",
    sticky: false,
    autoPan: true   // ðŸ‘ˆ keeps tooltips inside the viewport
  });
}

async function buildElevationProfile(routeCoords, z){
  const fullDistances = [0];
  for(let i=1;i<routeCoords.length;i++) {
    fullDistances[i] = fullDistances[i-1] + haversineMi(routeCoords[i-1], routeCoords[i]);
  }

  // Sample every 10th point (for speed) but keep aligned distances
  const sampled = [];
  const sampledDistances = [];
  for (let i=0;i<routeCoords.length;i+=10){
    sampled.push(routeCoords[i]);
    sampledDistances.push(fullDistances[i]);
  }
  // Always include the last point
  if (sampled[sampled.length-1] !== routeCoords[routeCoords.length-1]) {
    sampled.push(routeCoords[routeCoords.length-1]);
    sampledDistances.push(fullDistances[fullDistances.length-1]);
  }

  const meters=[];
  for (const [lat,lon] of sampled){ 
    meters.push(await getElevationMetersAt(lat,lon,z)); 
  }
  const feet = meters.map(m => (m!=null ? m*3.28084 : null));

  return { distances: sampledDistances, elevations: feet, sampled };
}


/* ========= GLOBALS ========= */
let elevChart = null,
    profileDistances = [],
    profileElevations = [],
    currentHighlightIndices = new Set();
let groupList = [];
let stationIndexToGroup = [];

/* ========= INTERPOLATION ========= */
function elevationAtMile(mile) {
  if (!profileDistances.length) return null;
  for (let i=1;i<profileDistances.length;i++) {
    if (profileDistances[i] >= mile) {
      const d0 = profileDistances[i-1], d1 = profileDistances[i];
      const e0 = profileElevations[i-1], e1 = profileElevations[i];
      if (e0==null || e1==null) return null;
      const t = (mile-d0)/(d1-d0);
      return e0 + t*(e1-e0);
    }
  }
  return profileElevations[profileElevations.length-1];
}

/* ========= CHART BUILDER ========= */
function buildElevationChart(distances, elevations, stations){
  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevChart) elevChart.destroy();

  profileDistances = distances;
  profileElevations = elevations;

  const stationPoints = stations.map(s => ({
    x: s.miles,
    y: elevationAtMile(s.miles)
  }));

  elevChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        {
          label: 'Elevation',
          data: profileDistances.map((d,i)=>({x:d, y:elevations[i]})),
          parsing: false,
          borderColor: '#000',
          pointRadius: 0,
          borderWidth: 1.5,
          fill: false,
          tension: 0.1
        },
        {
          label: 'Aid Stations',
          type: 'scatter',
          data: stationPoints,
          parsing: false,
          pointRadius: 6,
          hoverRadius: 10,
          hitRadius: 12,
pointBackgroundColor: (ctx) => {
  const idx = ctx.dataIndex;
  return (elevChart && currentHighlightIndices.has(idx))
    ? getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700'
    : getComputedStyle(document.documentElement).getPropertyValue('--blaze').trim() || '#37BC7D';
},
          pointBorderColor: '#222',
          pointBorderWidth: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
       tooltip: {
  enabled: true,
  filter: ctx => ctx.datasetIndex === 1,
  callbacks: {
    title: (ctx) => {
      const station = stations[ctx[0].dataIndex];
      return `${station.name} â€“ Mile ${station.miles.toFixed(1)}`;
    },
    label: (ctx) => {
      const station = stations[ctx.dataIndex];
      if (station.forecasts && station.forecasts.length) {
        return station.forecasts.map(f => [
          `ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}`,
          `Temp: ${f.temp}`,
          `Wind: ${f.wind}`,
          `Conditions: ${f.cond}`
        ]).flat();
      }
      return ["Forecast: â€”"];
    }
  },
  backgroundColor: '#fff',
  borderColor: getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() || '#FF6700',
  borderWidth: 2,
  titleColor: '#111',
  bodyColor: '#111',
  padding: 8,
  displayColors: false
}
      },
      interaction: { mode: 'point', intersect: true },
      onHover: (event, elements) => {
        const canvas = event.chart.canvas;
        if (elements.length > 0 && elements[0].datasetIndex === 1) {
          canvas.style.cursor = 'pointer';
          const idx = elements[0].index;
          highlightByStationIndex(idx);
        } else {
          canvas.style.cursor = 'default';
          clearHighlights();
          event.chart.tooltip.setActiveElements([], {x:0,y:0});
          event.chart.update();
        }
      },
      scales: {
        x: { type: 'linear', title: { display: true, text: 'Distance (mi)' }, min: 0, max: 100.9 },
        y: { title: { display: true, text: 'Elevation (ft)' }, ticks: { autoSkip: true, maxTicksLimit: 6 } }
      }
    }
  });

  ctx.canvas.addEventListener("mouseleave", () => {
    if (elevChart) {
      elevChart.tooltip.setActiveElements([], {x:0,y:0});
      elevChart.update();
      clearHighlights();
    }
  });
}

/* ========= MAP ========= */
const map = L.map('map', {
  scrollWheelZoom: true,
  touchZoom: true,
  zoomControl: true,
  dragging: true
}).setView([40.7682, -77.7559], 12);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap contributors'}).addTo(map);
let markers=[];

/* ========= HIGHLIGHT HELPERS ========= */
function applyMarkerHighlights(activeGroupIdx){
  markers.forEach((m,i)=>{
    const dot = m.getElement().querySelector('.blaze-dot');
    if (dot) dot.classList.toggle("highlighted", i === activeGroupIdx);
  });
}
function applyChartHighlights(indices){
  currentHighlightIndices = new Set(indices);
  if (elevChart){
    elevChart.setActiveElements(indices.map(i=>({datasetIndex:1,index:i})));
    elevChart.update();
  }
}
function highlightByStationIndex(stationIdx){
  const gIdx = stationIndexToGroup[stationIdx];
  applyMarkerHighlights(gIdx);
  applyChartHighlights([stationIdx]);
}
function highlightByGroupIndex(groupIdx){
  const indices = groupList[groupIdx].indices;
  applyMarkerHighlights(groupIdx);
  applyChartHighlights(indices);
}
function clearHighlights(){
  currentHighlightIndices.clear();
  markers.forEach(m=>m.getElement().querySelector('.blaze-dot')?.classList.remove("highlighted"));
  if(elevChart){ elevChart.setActiveElements([]); elevChart.update(); }
}

const blazeIcon = L.divIcon({
  className: "",
  html: '<div class="blaze-dot"></div>',
  iconSize: [20, 20],
  iconAnchor: [10, 10]
});

/* ========= BUILD EVERYTHING ========= */
Promise.all([
  fetch(raceConfig.routeUrl).then(r=>r.json()),
  fetch(raceConfig.stationsUrl).then(r=>r.json())
]).then(async([route,stations])=>{
  raceConfig.route=route; raceConfig.stations=stations;

  const line=L.polyline(route,{color:"#000",weight:3}).addTo(map);
  map.fitBounds(line.getBounds());

  try{
    const {distances,elevations}=await buildElevationProfile(route,raceConfig.elevationZoom);
    buildElevationChart(distances,elevations,stations);
  }catch(e){
    console.error('Elevation error',e);
    const distances=[0]; 
    for(let i=1;i<route.length;i++) distances[i]=distances[i-1]+haversineMi(route[i-1],route[i]);
    const elevations=distances.map(()=>1500);
    buildElevationChart(distances,elevations,stations);
  }

  const groupsByKey = {};
  stations.forEach((s, idx) => {
    const key = `${s.lat},${s.lon}`;
    if (!groupsByKey[key]) groupsByKey[key] = { lat:s.lat, lon:s.lon, indices:[] };
    groupsByKey[key].indices.push(idx);
  });
  groupList = Object.values(groupsByKey);

  groupList.forEach((g, gIdx) => {
    g.indices.forEach(stIdx => { stationIndexToGroup[stIdx] = gIdx; });
    const marker = L.marker([g.lat, g.lon], { icon: blazeIcon }).addTo(map);
    g.marker = marker;
    markers.push(marker);

    // âœ… Now safe to call
bindMarkerTooltip(marker);
marker.setTooltipContent(tooltipLinesMapGroup(g, stations));

marker.on("mouseover", () => highlightByGroupIndex(gIdx));
marker.on("mouseout", clearHighlights);

  });

updateForecasts();
groupList.forEach(g => {
  if (g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations));
});
});
</script>































<script>
/* ========= FORECASTS ========= */
function daysForecastAvailable(){ 
  return daysUntilRace() <= 7; 
}

/* Format one forecast */
function formatForecastLine(f, plain=false) {
  if (!f) return plain ? "Forecast: â€”" : "Forecast: â€”";
  if (plain) {
    return [
      `ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}`,
      `Temp: ${f.temp}`,
      `Wind: ${f.wind}`,
      `Conditions: ${f.cond}`
    ];
  }
  return `
    ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}<br>
    Temp: ${f.temp}<br>
    Wind: ${f.wind}<br>
    Conditions: ${f.cond}
  `;
}

/* Map tooltips (HTML, handles groups) */
function tooltipLinesMapGroup(g, stations) {
  let html = "";
  g.indices.forEach((i, idx) => {
    const s = stations[i];
    if (idx > 0) html += `<hr style="margin:6px 0;">`; // divider between passes
    html += `<div style="margin-bottom:6px;">
      <strong>${s.name} â€“ Mile ${s.miles.toFixed(1)}</strong><br>
    `;
    if (s.forecasts && s.forecasts.length) {
      s.forecasts.forEach(f => {
        html += `
          ETA: ${f.eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}<br>
          Temp: ${f.temp}<br>
          Wind: ${f.wind}<br>
          Conditions: ${f.cond}<br>
        `;
      });
    } else {
      html += `Forecast: â€”<br>`;
    }
    html += `</div>`;
  });
  return html;
}

/* Chart tooltips (array of strings) */
function tooltipLinesChart(station) {
  if (station.forecasts && station.forecasts.length) {
    let lines = [`${station.name} â€“ Mile ${station.miles.toFixed(1)}`];
    station.forecasts.forEach((f, idx) => {
      if (idx > 0) lines.push("----------------");
      lines.push(...formatForecastLine(f, true));
    });
    return lines;
  } else {
    return ["Forecast: â€”"];
  }
}

async function updateForecasts(){
  const tbody = document.getElementById("forecastBody"); 
  tbody.innerHTML = "";
  const forecastsAvailable = daysForecastAvailable();

  if(forecastsAvailable){
    document.getElementById("forecastValidLabel").textContent = "Fetching latest forecastâ€¦";
  } else {
    const unlockDate = new Date(raceConfig.date); 
    unlockDate.setDate(unlockDate.getDate() - 7);
    document.getElementById("forecastValidLabel").textContent =
      `Forecast unlocks on ${unlockDate.toLocaleDateString([], {month:"short", day:"numeric", year:"numeric"})}`;
  }

  const pace = paceMinPerMiFromUI();

  for (const s of raceConfig.stations){
    const eta = new Date(raceConfig.date.getTime() + s.miles * pace * 60000);
    const timeStr = eta.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"});

    let temp="â€”", wind="â€”", cond="â€”", wbgtCell={label:"â€”",cls:"wbgt-na",desc:"No data"};
    let forecastObj=null;

    if (forecastsAvailable){
      const f = await getNOAAForecast(s.lat, s.lon, eta);
      if (f){
        // Temp
        let tVal = f.temperature;
        temp = (tVal!=null) ? `${tVal}Â°F` : "â€”";

        // Wind: NWS API gives windSpeed ("5 mph") and windDirection ("NW")
        const speed = f.windSpeed || "";
        const dir = f.windDirection || "";
        wind = (speed || dir) ? `${speed} ${dir}`.trim() : "â€”";

        cond = f.shortForecast || "â€”";

        // WBGT (table only)
        const rh = f.relativeHumidity?.value;
        const wbgtVal = (f.temperature && rh!=null) ? wbgtShadeF(f.temperature, rh) : null;
        wbgtCell = wbgtClass(wbgtVal, raceConfig.regionCategory);

        forecastObj=f;
      }
    }
    s.forecastObj=forecastObj;

    const row=document.createElement("tr");
    row.innerHTML=`
      <td>${s.name}</td>
      <td>${s.miles.toFixed(1)} mi</td>
      <td>${timeStr}</td>
      <td>${temp}</td>
      <td>${wind}</td>
      <td>${cond}</td>
      <td class="${wbgtCell.cls}" title="${wbgtCell.desc}">${wbgtCell.label}</td>
    `;
    tbody.appendChild(row);
    s._row=row;

    s.forecasts=[{ eta,temp,wind,cond, wbgt: wbgtCell.label }];
  }

  document.getElementById("forecastNote").style.display = forecastsAvailable ? "none" : "block";
  if(forecastsAvailable){
    document.getElementById("forecastValidLabel").textContent =
      `Forecast valid as of ${new Date().toLocaleString()}`;
  }

  // Refresh all map tooltips with grouped content
  if(groupList && groupList.length){
    groupList.forEach(g=>{
      if(g.marker) g.marker.setTooltipContent(tooltipLinesMapGroup(g, raceConfig.stations));
    });
  }
}
</script>














